# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0> = clone<'_0_0, Self>[Self]
    non-dyn-compatible
}

// Full name: core::clone::Clone::clone
#[lang_item("clone_fn")]
pub fn clone<'_0, Self>(@1: &'_0 (Self)) -> Self
where
    [@TraitClause0]: Clone<Self>,

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>
where
    'a : 'a,

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::panicking::panic
#[lang_item("panic")]
pub fn panic(@1: &'static (Str)) -> !

// Full name: core::panicking::AssertKind
pub enum AssertKind {
  Eq,
  Ne,
  Match,
}

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: test_crate::Super
trait Super<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn super_method<'_0> = test_crate::Super::super_method<'_0_0, Self, T>[Self]
    vtable: test_crate::Super::{vtable}<T>
}

fn test_crate::Super::super_method<'_0, Self, T>(@1: &'_0 (Self), @2: T) -> i32
where
    [@TraitClause0]: Super<Self, T>,

struct test_crate::Checkable::{vtable}<T> {
  size: usize,
  align: usize,
  drop: fn(*mut (dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, T> + _dyn : '_)),
  method_check: fn<'_0>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, T> + _dyn : '_))) -> bool,
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
  super_trait_1: &'static (test_crate::Super::{vtable}<T>),
}

// Full name: test_crate::Checkable
trait Checkable<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Super<Self, T>
    parent_clause2 : [@TraitClause2]: Sized<T>
    fn check<'_0> = test_crate::Checkable::check<'_0_0, Self, T>[Self]
    vtable: test_crate::Checkable::{vtable}<T>
}

fn test_crate::Checkable::check<'_0, Self, T>(@1: &'_0 (Self)) -> bool
where
    [@TraitClause0]: Checkable<Self, T>,

// Full name: test_crate::{impl Super<i32> for i32}::super_method
fn {impl Super<i32> for i32}::super_method<'_0>(@1: &'_0 (i32), @2: i32) -> i32
{
    let @0: i32; // return
    let self@1: &'_ (i32); // arg #1
    let arg@2: i32; // arg #2
    let @3: i32; // anonymous local
    let @4: i32; // anonymous local
    let @5: i32; // anonymous local

    storage_live(@5)
    storage_live(@3)
    @3 := copy (*(self@1))
    storage_live(@4)
    @4 := copy (arg@2)
    @5 := copy (@3) panic.+ copy (@4)
    @0 := move (@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::{impl Super<i32> for i32}
impl Super<i32> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i32>
    fn super_method<'_0> = {impl Super<i32> for i32}::super_method<'_0_0>
    vtable: {impl Super<i32> for i32}::{vtable}
}

// Full name: test_crate::{impl Checkable<i32> for i32}::check
fn {impl Checkable<i32> for i32}::check<'_0>(@1: &'_0 (i32)) -> bool
{
    let @0: bool; // return
    let self@1: &'_ (i32); // arg #1
    let @2: i32; // anonymous local
    let @3: &'_ (i32); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &*(self@1)
    @2 := {impl Super<i32> for i32}::super_method<'_>(move (@3), const (10 : i32))
    storage_dead(@3)
    @0 := move (@2) > const (0 : i32)
    storage_dead(@2)
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::check::{vtable_method}
fn {impl Checkable<i32> for i32}::check::{vtable_method}<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_))) -> bool
{
    let @0: bool; // return
    let @1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)); // arg #1
    let @2: &'_0 (i32); // anonymous local

    storage_live(@0)
    storage_live(@1)
    storage_live(@2)
    @2 := concretize<&'_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)), &'_0 (i32)>(move (@1))
    @0 := {impl Checkable<i32> for i32}::check<'_0>(move (@2))
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::{vtable}
fn {impl Checkable<i32> for i32}::{vtable}() -> test_crate::Checkable::{vtable}<i32>
{
    let ret@0: test_crate::Checkable::{vtable}<i32>; // return
    let @1: &'static (test_crate::Super::{vtable}<i32>); // anonymous local

    storage_live(@1)
    @1 := &{impl Super<i32> for i32}::{vtable}
    ret@0 := test_crate::Checkable::{vtable} { size: const (Opaque(unknown size)), align: const (Opaque(unknown align)), drop: const (Opaque(unknown drop)), method_check: const ({impl Checkable<i32> for i32}::check::{vtable_method}<'_>), super_trait_0: const (Opaque(missing supertrait vtable)), super_trait_1: move (@1) }
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::{vtable}
static {impl Checkable<i32> for i32}::{vtable}: test_crate::Checkable::{vtable}<i32> = {impl Checkable<i32> for i32}::{vtable}()

// Full name: test_crate::{impl Checkable<i32> for i32}
impl Checkable<i32> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = {impl Super<i32> for i32}
    parent_clause2 = Sized<i32>
    fn check<'_0> = {impl Checkable<i32> for i32}::check<'_0_0>
    vtable: {impl Checkable<i32> for i32}::{vtable}
}

struct test_crate::NoParam::{vtable} {
  size: usize,
  align: usize,
  drop: fn(*mut (dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)),
  method_dummy: fn<'_0>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_))),
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::NoParam
trait NoParam<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn dummy<'_0> = test_crate::NoParam::dummy<'_0_0, Self>[Self]
    vtable: test_crate::NoParam::{vtable}
}

fn test_crate::NoParam::dummy<'_0, Self>(@1: &'_0 (Self))
where
    [@TraitClause0]: NoParam<Self>,

// Full name: test_crate::{impl NoParam for i32}::dummy
fn {impl NoParam for i32}::dummy<'_0>(@1: &'_0 (i32))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let @2: (); // anonymous local
    let @3: bool; // anonymous local
    let @4: i32; // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := copy (*(self@1))
    @3 := move (@4) > const (0 : i32)
    if move (@3) {
    }
    else {
        storage_dead(@4)
        panic(core::panicking::panic)
    }
    storage_dead(@4)
    storage_dead(@3)
    storage_dead(@2)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl NoParam for i32}
impl NoParam for i32 {
    parent_clause0 = MetaSized<i32>
    fn dummy<'_0> = {impl NoParam for i32}::dummy<'_0_0>
    vtable: {impl NoParam for i32}::{vtable}
}

// Full name: test_crate::to_dyn_obj
fn to_dyn_obj<'_0, T>(@1: &'_0 (T)) -> &'_0 ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_0))
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: NoParam<T>,
{
    let @0: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // return
    let arg@1: &'_ (T); // arg #1
    let @2: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // anonymous local
    let @3: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // anonymous local
    let @4: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := &*(arg@1)
    @3 := unsize_cast<&'_ (T), &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), @TraitClause1>(move (@4))
    storage_dead(@4)
    @2 := &*(@3)
    @0 := unsize_cast<&'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), NoParam<(dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)>>(move (@2))
    storage_dead(@3)
    storage_dead(@2)
    return
}

struct test_crate::Modifiable::{vtable}<T> {
  size: usize,
  align: usize,
  drop: fn(*mut (dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)),
  method_modify: fn<'_0, '_1>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), &'_0_1 (T)) -> T,
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::Modifiable
trait Modifiable<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn modify<'_0, '_1> = test_crate::Modifiable::modify<'_0_0, '_0_1, Self, T>[Self]
    vtable: test_crate::Modifiable::{vtable}<T>
}

fn test_crate::Modifiable::modify<'_0, '_1, Self, T>(@1: &'_0 mut (Self), @2: &'_1 (T)) -> T
where
    [@TraitClause0]: Modifiable<Self, T>,

// Full name: test_crate::{impl Modifiable<T> for i32}::modify
fn {impl Modifiable<T> for i32}::modify<'_0, '_1, T>(@1: &'_0 mut (i32), @2: &'_1 (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let @0: T; // return
    let self@1: &'_ mut (i32); // arg #1
    let arg@2: &'_ (T); // arg #2
    let @3: i32; // anonymous local
    let @4: &'_ (T); // anonymous local

    storage_live(@3)
    @3 := copy (*(self@1)) panic.+ const (1 : i32)
    *(self@1) := move (@3)
    storage_live(@4)
    @4 := &*(arg@2)
    @0 := @TraitClause1::clone<'_>(move (@4))
    storage_dead(@4)
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::modify::{vtable_method}
fn {impl Modifiable<T> for i32}::modify::{vtable_method}<'_0, '_1, T>(@1: &'_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), @2: &'_1 (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let @0: T; // return
    let @1: &'_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)); // arg #1
    let @2: &'_1 (T); // arg #2
    let @3: &'_0 mut (i32); // anonymous local

    storage_live(@0)
    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    @3 := concretize<&'_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), &'_0 mut (i32)>(move (@1))
    @0 := {impl Modifiable<T> for i32}::modify<'_0, '_1, T>[@TraitClause0, @TraitClause1](move (@3), move (@2))
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::{vtable}
fn {impl Modifiable<T> for i32}::{vtable}<T>() -> test_crate::Modifiable::{vtable}<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let ret@0: test_crate::Modifiable::{vtable}<T>; // return

    ret@0 := test_crate::Modifiable::{vtable} { size: const (Opaque(unknown size)), align: const (Opaque(unknown align)), drop: const (Opaque(unknown drop)), method_modify: const ({impl Modifiable<T> for i32}::modify::{vtable_method}<'_, '_, T>[@TraitClause0, @TraitClause1]), super_trait_0: const (Opaque(missing supertrait vtable)) }
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::{vtable}
static {impl Modifiable<T> for i32}::{vtable}<T>: test_crate::Modifiable::{vtable}<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
 = {impl Modifiable<T> for i32}::{vtable}()

// Full name: test_crate::{impl Modifiable<T> for i32}
impl<T> Modifiable<T> for i32
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    parent_clause0 = MetaSized<i32>
    parent_clause1 = @TraitClause0
    fn modify<'_0, '_1> = {impl Modifiable<T> for i32}::modify<'_0_0, '_0_1, T>[@TraitClause0, @TraitClause1]
    vtable: {impl Modifiable<T> for i32}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::modify_trait_object
fn modify_trait_object<'_0, T>(@1: &'_0 (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,

// Full name: test_crate::BaseOn
trait BaseOn<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn operate_on<'_0, '_1> = test_crate::BaseOn::operate_on<'_0_0, '_0_1, Self, T>[Self]
    vtable: test_crate::BaseOn::{vtable}<T>
}

fn test_crate::BaseOn::operate_on<'_0, '_1, Self, T>(@1: &'_0 (Self), @2: &'_1 (T))
where
    [@TraitClause0]: BaseOn<Self, T>,

struct test_crate::Both32And64::{vtable} {
  size: usize,
  align: usize,
  drop: fn(*mut (dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)),
  method_both_operate: fn<'_0, '_1, '_2>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)), &'_0_1 (i32), &'_0_2 (i64)),
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
  super_trait_1: &'static (test_crate::BaseOn::{vtable}<i32>),
  super_trait_2: &'static (test_crate::BaseOn::{vtable}<i64>),
}

// Full name: test_crate::Both32And64
trait Both32And64<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: BaseOn<Self, i32>
    parent_clause2 : [@TraitClause2]: BaseOn<Self, i64>
    fn both_operate<'_0, '_1, '_2> = both_operate<'_0_0, '_0_1, '_0_2, Self>[Self]
    vtable: test_crate::Both32And64::{vtable}
}

// Full name: test_crate::Both32And64::both_operate
fn both_operate<'_0, '_1, '_2, Self>(@1: &'_0 (Self), @2: &'_1 (i32), @3: &'_2 (i64))
where
    [@TraitClause0]: Both32And64<Self>,
{
    let @0: (); // return
    let self@1: &'_ (Self); // arg #1
    let t32@2: &'_ (i32); // arg #2
    let t64@3: &'_ (i64); // arg #3
    let @4: (); // anonymous local
    let @5: &'_ (Self); // anonymous local
    let @6: &'_ (i32); // anonymous local
    let @7: (); // anonymous local
    let @8: &'_ (Self); // anonymous local
    let @9: &'_ (i64); // anonymous local

    storage_live(@4)
    storage_live(@5)
    @5 := &*(self@1)
    storage_live(@6)
    @6 := &*(t32@2)
    @4 := @TraitClause0::parent_clause1::operate_on<'_, '_>(move (@5), move (@6))
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@7)
    storage_live(@8)
    @8 := &*(self@1)
    storage_live(@9)
    @9 := &*(t64@3)
    @7 := @TraitClause0::parent_clause2::operate_on<'_, '_>(move (@8), move (@9))
    storage_dead(@9)
    storage_dead(@8)
    storage_dead(@7)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}::operate_on
fn {impl BaseOn<i32> for i32}::operate_on<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let t@2: &'_ (i32); // arg #2
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: i32; // anonymous local
    let @6: i32; // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (*(self@1))
    storage_live(@6)
    @6 := copy (*(t@2))
    @4 := move (@5) > move (@6)
    if move (@4) {
    }
    else {
        storage_dead(@6)
        storage_dead(@5)
        panic(core::panicking::panic)
    }
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}
impl BaseOn<i32> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i32>
    fn operate_on<'_0, '_1> = {impl BaseOn<i32> for i32}::operate_on<'_0_0, '_0_1>
    vtable: {impl BaseOn<i32> for i32}::{vtable}
}

// Full name: test_crate::{impl BaseOn<i64> for i32}::operate_on
fn {impl BaseOn<i64> for i32}::operate_on<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i64))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let t@2: &'_ (i64); // arg #2
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: i64; // anonymous local
    let @6: i32; // anonymous local
    let @7: i64; // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := copy (*(self@1))
    @5 := cast<i32, i64>(move (@6))
    storage_dead(@6)
    storage_live(@7)
    @7 := copy (*(t@2))
    @4 := move (@5) > move (@7)
    if move (@4) {
    }
    else {
        storage_dead(@7)
        storage_dead(@5)
        panic(core::panicking::panic)
    }
    storage_dead(@7)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl BaseOn<i64> for i32}
impl BaseOn<i64> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i64>
    fn operate_on<'_0, '_1> = {impl BaseOn<i64> for i32}::operate_on<'_0_0, '_0_1>
    vtable: {impl BaseOn<i64> for i32}::{vtable}
}

fn test_crate::{impl Both32And64 for i32}::both_operate<'_0, '_1, '_2>(@1: &'_0 (i32), @2: &'_1 (i32), @3: &'_2 (i64))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let t32@2: &'_ (i32); // arg #2
    let t64@3: &'_ (i64); // arg #3
    let @4: (); // anonymous local
    let @5: &'_ (i32); // anonymous local
    let @6: &'_ (i32); // anonymous local
    let @7: (); // anonymous local
    let @8: &'_ (i32); // anonymous local
    let @9: &'_ (i64); // anonymous local

    storage_live(@4)
    storage_live(@5)
    @5 := &*(self@1)
    storage_live(@6)
    @6 := &*(t32@2)
    @4 := {impl Both32And64 for i32}::parent_clause1::operate_on<'_, '_>(move (@5), move (@6))
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@7)
    storage_live(@8)
    @8 := &*(self@1)
    storage_live(@9)
    @9 := &*(t64@3)
    @7 := {impl Both32And64 for i32}::parent_clause2::operate_on<'_, '_>(move (@8), move (@9))
    storage_dead(@9)
    storage_dead(@8)
    storage_dead(@7)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl Both32And64 for i32}
impl Both32And64 for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = {impl BaseOn<i32> for i32}
    parent_clause2 = {impl BaseOn<i64> for i32}
    fn both_operate<'_0, '_1, '_2> = test_crate::{impl Both32And64 for i32}::both_operate<'_0_0, '_0_1, '_0_2>
    vtable: {impl Both32And64 for i32}::{vtable}
}

// Full name: test_crate::Alias
trait Alias<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Both32And64<Self>
    vtable: test_crate::Alias::{vtable}
}

struct test_crate::LifetimeTrait::{vtable}<Ty0> {
  size: usize,
  align: usize,
  drop: fn(*mut (dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0)),
  method_lifetime_method: fn<'a, '_1>(&'_0_1 ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0)), &'a (LifetimeTrait<(dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0)>::Ty)) -> &'a (LifetimeTrait<(dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0)>::Ty),
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::LifetimeTrait
trait LifetimeTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Ty>
    type Ty
    fn lifetime_method<'a, '_1> = test_crate::LifetimeTrait::lifetime_method<'a, '_0_1, Self>[Self]
    vtable: test_crate::LifetimeTrait::{vtable}<Self::Ty>
}

fn test_crate::LifetimeTrait::lifetime_method<'a, '_1, Self>(@1: &'_1 (Self), @2: &'a (@TraitClause0::Ty)) -> &'a (@TraitClause0::Ty)
where
    [@TraitClause0]: LifetimeTrait<Self>,

// Full name: test_crate::{impl LifetimeTrait for i32}::lifetime_method
fn {impl LifetimeTrait for i32}::lifetime_method<'a, '_1>(@1: &'_1 (i32), @2: &'a (i32)) -> &'a (i32)
{
    let @0: &'_ (i32); // return
    let self@1: &'_ (i32); // arg #1
    let arg@2: &'_ (i32); // arg #2
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: i32; // anonymous local
    let @6: i32; // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (*(self@1))
    storage_live(@6)
    @6 := copy (*(arg@2))
    @4 := move (@5) > move (@6)
    if move (@4) {
    }
    else {
        storage_dead(@6)
        storage_dead(@5)
        panic(core::panicking::panic)
    }
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    @0 := copy (arg@2)
    return
}

// Full name: test_crate::{impl LifetimeTrait for i32}
impl LifetimeTrait for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i32>
    type Ty = i32
    fn lifetime_method<'a, '_1> = {impl LifetimeTrait for i32}::lifetime_method<'a, '_0_1>
    vtable: {impl LifetimeTrait for i32}::{vtable}
}

// Full name: test_crate::use_lifetime_trait
fn use_lifetime_trait<'a, '_1>(@1: &'_1 ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_1 + @TraitClause1_0::Ty = i32)), @2: &'a (i32)) -> &'a (i32)

// Full name: test_crate::use_alias
fn use_alias<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_0)))

// Full name: test_crate::main
fn main()



