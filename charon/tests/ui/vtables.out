# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0> = core::clone::Clone::clone<'_0_0, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 (Self)) -> Self
where
    [@TraitClause0]: Clone<Self>,

// Full name: core::clone::impls::{impl Clone for i32}::clone
pub fn {impl Clone for i32}::clone<'_0>(@1: &'_0 (i32)) -> i32

// Full name: core::clone::impls::{impl Clone for i32}
impl Clone for i32 {
    parent_clause0 = Sized<i32>
    fn clone<'_0> = {impl Clone for i32}::clone<'_0_0>
    non-dyn-compatible
}

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0, '_1> = core::cmp::PartialEq::eq<'_0_0, '_0_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,

// Full name: core::cmp::Eq
#[lang_item("Eq")]
pub trait Eq<Self>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Self>
    non-dyn-compatible
}

// Full name: core::ops::drop::Drop
#[lang_item("drop")]
pub trait Drop<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn drop<'_0> = core::ops::drop::Drop::drop<'_0_0, Self>[Self]
    vtable: core::ops::drop::Drop::{vtable}
}

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::cmp::Ordering::{impl Drop for Ordering}
impl Drop for Ordering {
    parent_clause0 = MetaSized<Ordering>
    fn drop<'_0> = {impl Drop for Ordering}::drop<'_0_0>
    non-dyn-compatible
}

// Full name: core::cmp::Ordering::{impl Drop for Ordering}::drop
fn {impl Drop for Ordering}::drop<'_0>(@1: &'_0 mut (Ordering))

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0, '_1> = core::cmp::PartialOrd::partial_cmp<'_0_0, '_0_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

// Full name: core::cmp::Ord
#[lang_item("Ord")]
pub trait Ord<Self>
{
    parent_clause0 : [@TraitClause0]: Eq<Self>
    parent_clause1 : [@TraitClause1]: PartialOrd<Self, Self>
    fn cmp<'_0, '_1> = core::cmp::Ord::cmp<'_0_0, '_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("ord_cmp_method")]
pub fn core::cmp::Ord::cmp<'_0, '_1, Self>(@1: &'_0 (Self), @2: &'_1 (Self)) -> Ordering
where
    [@TraitClause0]: Ord<Self>,

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> Option<Ordering>[Sized<Ordering>]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,

// Full name: core::default::Default
#[lang_item("Default")]
pub trait Default<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn default = default<Self>[Self]
    non-dyn-compatible
}

// Full name: core::default::Default::default
#[lang_item("default_fn")]
pub fn default<Self>() -> Self
where
    [@TraitClause0]: Default<Self>,

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::fmt::Error::{impl Drop for Error}
impl Drop for Error {
    parent_clause0 = MetaSized<Error>
    fn drop<'_0> = {impl Drop for Error}::drop<'_0_0>
    non-dyn-compatible
}

// Full name: core::fmt::Error::{impl Drop for Error}::drop
fn {impl Drop for Error}::drop<'_0>(@1: &'_0 mut (Error))

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>
where
    'a : 'a,

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Display
#[lang_item("Display")]
pub trait Display<Self>
{
    fn fmt<'_0, '_1, '_2> = core::fmt::Display::fmt<'_0_0, '_0_1, '_0_2, Self>[Self]
    vtable: core::fmt::Display::{vtable}
}

pub fn core::fmt::Display::fmt<'_0, '_1, '_2, Self>(@1: &'_0 (Self), @2: &'_1 mut (Formatter<'_2>)) -> Result<(), Error>[Sized<()>, Sized<Error>]
where
    [@TraitClause0]: Display<Self>,

// Full name: core::fmt::{impl Display for Str}::fmt
pub fn {impl Display for Str}::fmt<'_0, '_1, '_2>(@1: &'_0 (Str), @2: &'_1 mut (Formatter<'_2>)) -> Result<(), Error>[Sized<()>, Sized<Error>]

// Full name: core::fmt::{impl Display for Str}
impl Display for Str {
    fn fmt<'_0, '_1, '_2> = {impl Display for Str}::fmt<'_0_0, '_0_1, '_0_2>
    vtable: {impl Display for Str}::{vtable}
}

// Full name: core::iter::adapters::map::Map
pub opaque type Map<I, F>
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Sized<F>,

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self::Output>
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0> = core::ops::function::FnMut::call_mut<'_0_0, Self, Args>[Self]
    vtable: core::ops::function::FnMut::{vtable}<Args, Self::parent_clause1::Output>
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0> = core::iter::traits::iterator::Iterator::next<'_0_0, Self>[Self]
    fn map<B, F, [@TraitClause0]: Sized<B>, [@TraitClause1]: Sized<F>, [@TraitClause2]: Sized<Self>, [@TraitClause3]: FnMut<F, (Self::Item)>, @TraitClause1_3::parent_clause1::Output = B> = map<Self, B, F>[Self, @TraitClause0_0, @TraitClause0_1, @TraitClause0_2, @TraitClause0_3]
    fn sum<S, [@TraitClause0]: Sized<S>, [@TraitClause1]: Sized<Self>, [@TraitClause2]: Sum<S, Self::Item>> = core::iter::traits::iterator::Iterator::sum<Self, S>[Self, @TraitClause0_0, @TraitClause0_1, @TraitClause0_2]
    vtable: core::iter::traits::iterator::Iterator::{vtable}<Self::Item>
}

// Full name: core::iter::traits::accum::Sum
pub trait Sum<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn sum<I, [@TraitClause0]: Sized<I>, [@TraitClause1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Sum::sum<Self, A, I>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::iter::adapters::map::{impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::next
pub fn {impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::next<'_0, B, I, F>(@1: &'_0 mut (Map<I, F>[@TraitClause0, @TraitClause1])) -> Option<B>[@TraitClause4]
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Iterator<I>,
    [@TraitClause3]: FnMut<F, (@TraitClause2::Item)>,
    [@TraitClause4]: Sized<B>,
    @TraitClause3::parent_clause1::Output = B,

#[lang_item("IteratorMap")]
pub fn core::iter::adapters::map::{impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::map<B, I, F, B, F>(@1: Map<I, F>[@TraitClause0, @TraitClause1], @2: F) -> Map<Map<I, F>[@TraitClause0, @TraitClause1], F>[@TraitClause7, @TraitClause6]
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Iterator<I>,
    [@TraitClause3]: FnMut<F, (@TraitClause2::Item)>,
    [@TraitClause4]: Sized<B>,
    [@TraitClause5]: Sized<B>,
    [@TraitClause6]: Sized<F>,
    [@TraitClause7]: Sized<Map<I, F>[@TraitClause0, @TraitClause1]>,
    [@TraitClause8]: FnMut<F, (B)>,
    @TraitClause3::parent_clause1::Output = B,
    @TraitClause8::parent_clause1::Output = B,

pub fn core::iter::adapters::map::{impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::sum<B, I, F, S>(@1: Map<I, F>[@TraitClause0, @TraitClause1]) -> S
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Iterator<I>,
    [@TraitClause3]: FnMut<F, (@TraitClause2::Item)>,
    [@TraitClause4]: Sized<B>,
    [@TraitClause5]: Sized<S>,
    [@TraitClause6]: Sized<Map<I, F>[@TraitClause0, @TraitClause1]>,
    [@TraitClause7]: Sum<S, B>,
    @TraitClause3::parent_clause1::Output = B,

// Full name: core::iter::adapters::map::{impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}
impl<B, I, F> Iterator for Map<I, F>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Iterator<I>,
    [@TraitClause3]: FnMut<F, (@TraitClause2::Item)>,
    [@TraitClause4]: Sized<B>,
    @TraitClause3::parent_clause1::Output = B,
{
    parent_clause0 = MetaSized<Map<I, F>[@TraitClause0, @TraitClause1]>
    parent_clause1 = @TraitClause4
    type Item = B
    fn next<'_0> = {impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::next<'_0_0, B, I, F>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3, @TraitClause4]
    fn map<B, F, [@TraitClause0]: Sized<B>, [@TraitClause1]: Sized<F>, [@TraitClause2]: Sized<Map<I, F>[@TraitClause0, @TraitClause1]>, [@TraitClause3]: FnMut<F, (B)>, @TraitClause1_3::parent_clause1::Output = B> = core::iter::adapters::map::{impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::map<B, I, F, B, F>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3, @TraitClause4, @TraitClause0_0, @TraitClause0_1, @TraitClause0_2, @TraitClause0_3]
    fn sum<S, [@TraitClause0]: Sized<S>, [@TraitClause1]: Sized<Map<I, F>[@TraitClause0, @TraitClause1]>, [@TraitClause2]: Sum<S, B>> = core::iter::adapters::map::{impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::sum<B, I, F, S>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3, @TraitClause4, @TraitClause0_0, @TraitClause0_1, @TraitClause0_2]
    vtable: {impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::{vtable}<B, I, F>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3, @TraitClause4]
}

// Full name: core::iter::adapters::zip::TrustedRandomAccessNoCoerce
pub trait TrustedRandomAccessNoCoerce<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const MAY_HAVE_SIDE_EFFECT : bool
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Sum::sum<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Sum<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::accum::Product
pub trait Product<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn product<I, [@TraitClause0]: Sized<I>, [@TraitClause1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Product::product<Self, A, I>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Product::product<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Product<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::accum::{impl Sum<usize> for usize}::sum
pub fn {impl Sum<usize> for usize}::sum<I>(@1: I) -> usize
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
    @TraitClause1::Item = usize,

// Full name: core::iter::traits::accum::{impl Sum<usize> for usize}
impl Sum<usize> for usize {
    parent_clause0 = Sized<usize>
    parent_clause1 = Sized<usize>
    fn sum<I, [@TraitClause0]: Sized<I>, [@TraitClause1]: Iterator<I>, @TraitClause1_1::Item = usize> = {impl Sum<usize> for usize}::sum<I>[@TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::IntoIterator
#[lang_item("IntoIterator")]
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = into_iter<Self>[Self]
    vtable: core::iter::traits::collect::IntoIterator::{vtable}<Self::Item, Self::IntoIter>
}

// Full name: core::iter::traits::collect::FromIterator
#[lang_item("FromIterator")]
pub trait FromIterator<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn from_iter<T, [@TraitClause0]: Sized<T>, [@TraitClause1]: IntoIterator<T>, @TraitClause1_1::Item = A> = from_iter<Self, A, T>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::FromIterator::from_iter
#[lang_item("from_iter_fn")]
pub fn from_iter<Self, A, T>(@1: T) -> Self
where
    [@TraitClause0]: FromIterator<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::collect::IntoIterator::into_iter
#[lang_item("into_iter")]
pub fn into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,

// Full name: core::iter::traits::collect::Extend
pub trait Extend<Self, A>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn extend<'_0, T, [@TraitClause0]: Sized<T>, [@TraitClause1]: IntoIterator<T>, @TraitClause1_1::Item = A> = extend<'_0_0, Self, A, T>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::Extend::extend
pub fn extend<'_0, Self, A, T>(@1: &'_0 mut (Self), @2: T)
where
    [@TraitClause0]: Extend<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::double_ended::DoubleEndedIterator
#[lang_item("DoubleEndedIterator")]
pub trait DoubleEndedIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    fn next_back<'_0> = next_back<'_0_0, Self>[Self]
    vtable: core::iter::traits::double_ended::DoubleEndedIterator::{vtable}<Self::parent_clause1::Item>
}

// Full name: core::iter::traits::double_ended::DoubleEndedIterator::next_back
pub fn next_back<'_0, Self>(@1: &'_0 mut (Self)) -> Option<@TraitClause0::parent_clause1::Item>[@TraitClause0::parent_clause1::parent_clause1]
where
    [@TraitClause0]: DoubleEndedIterator<Self>,

// Full name: core::iter::traits::exact_size::ExactSizeIterator
pub trait ExactSizeIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    vtable: core::iter::traits::exact_size::ExactSizeIterator::{vtable}<Self::parent_clause1::Item>
}

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut (Self)) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,

// Full name: core::iter::traits::iterator::Iterator::map
#[lang_item("IteratorMap")]
pub fn map<Self, B, F>(@1: Self, @2: F) -> Map<Self, F>[@TraitClause3, @TraitClause2]
where
    [@TraitClause0]: Iterator<Self>,
    [@TraitClause1]: Sized<B>,
    [@TraitClause2]: Sized<F>,
    [@TraitClause3]: Sized<Self>,
    [@TraitClause4]: FnMut<F, (@TraitClause0::Item)>,
    @TraitClause4::parent_clause1::Output = B,

pub fn core::iter::traits::iterator::Iterator::sum<Self, S>(@1: Self) -> S
where
    [@TraitClause0]: Iterator<Self>,
    [@TraitClause1]: Sized<S>,
    [@TraitClause2]: Sized<Self>,
    [@TraitClause3]: Sum<S, @TraitClause0::Item>,

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::ops::control_flow::ControlFlow
#[lang_item("ControlFlow")]
pub enum ControlFlow<B, C>
where
    [@TraitClause0]: Sized<B>,
    [@TraitClause1]: Sized<C>,
{
  Continue(C),
  Break(B),
}

pub fn core::ops::drop::Drop::drop<'_0, Self>(@1: &'_0 mut (Self))
where
    [@TraitClause0]: Drop<Self>,

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut (Self), @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,

// Full name: core::ops::try_trait::FromResidual
#[lang_item("FromResidual")]
pub trait FromResidual<Self, R>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<R>
    fn from_residual = from_residual<Self, R>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try
#[lang_item("Try")]
pub trait Try<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FromResidual<Self, Self::Residual>
    parent_clause2 : [@TraitClause2]: Sized<Self::Output>
    parent_clause3 : [@TraitClause3]: Sized<Self::Residual>
    type Output
    type Residual
    fn from_output = from_output<Self>[Self]
    fn branch = branch<Self>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try::from_output
#[lang_item("from_output")]
pub fn from_output<Self>(@1: @TraitClause0::Output) -> Self
where
    [@TraitClause0]: Try<Self>,

// Full name: core::ops::try_trait::Try::branch
#[lang_item("branch")]
pub fn branch<Self>(@1: Self) -> ControlFlow<@TraitClause0::Residual, @TraitClause0::Output>[@TraitClause0::parent_clause1::parent_clause1, @TraitClause0::parent_clause2]
where
    [@TraitClause0]: Try<Self>,

// Full name: core::ops::try_trait::FromResidual::from_residual
#[lang_item("from_residual")]
pub fn from_residual<Self, R>(@1: R) -> Self
where
    [@TraitClause0]: FromResidual<Self, R>,

// Full name: core::ops::try_trait::Residual
pub trait Residual<Self, O>
where
    Self::parent_clause3::Output = O,
    Self::parent_clause3::Residual = Self,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<O>
    parent_clause2 : [@TraitClause2]: Sized<Self::TryType>
    parent_clause3 : [@TraitClause3]: Try<Self::TryType>
    type TryType
    vtable: core::ops::try_trait::Residual::{vtable}<O, Self::TryType>
}

// Full name: core::panicking::AssertKind
pub enum AssertKind {
  Eq,
  Ne,
  Match,
}

// Full name: core::panicking::AssertKind::{impl Drop for AssertKind}
impl Drop for AssertKind {
    parent_clause0 = MetaSized<AssertKind>
    fn drop<'_0> = {impl Drop for AssertKind}::drop<'_0_0>
    non-dyn-compatible
}

// Full name: core::panicking::AssertKind::{impl Drop for AssertKind}::drop
fn {impl Drop for AssertKind}::drop<'_0>(@1: &'_0 mut (AssertKind))

// Full name: core::slice::iter::Iter
#[lang_item("SliceIter")]
pub opaque type Iter<'a, T>
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
    T : 'a,

// Full name: core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::next
pub fn {impl Iterator for Iter<'a, T>[@TraitClause0]}::next<'a, '_1, T>(@1: &'_1 mut (Iter<'a, T>[@TraitClause0])) -> Option<&'a (T)>[Sized<&'_ (T)>]
where
    [@TraitClause0]: Sized<T>,

#[lang_item("IteratorMap")]
pub fn core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::map<'a, T, B, F>(@1: Iter<'a, T>[@TraitClause0], @2: F) -> Map<Iter<'a, T>[@TraitClause0], F>[@TraitClause3, @TraitClause2]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<B>,
    [@TraitClause2]: Sized<F>,
    [@TraitClause3]: Sized<Iter<'a, T>[@TraitClause0]>,
    [@TraitClause4]: FnMut<F, (&'a (T))>,
    @TraitClause4::parent_clause1::Output = B,

pub fn core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::sum<'a, T, S>(@1: Iter<'a, T>[@TraitClause0]) -> S
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<S>,
    [@TraitClause2]: Sized<Iter<'a, T>[@TraitClause0]>,
    [@TraitClause3]: Sum<S, &'a (T)>,

// Full name: core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}
impl<'a, T> Iterator for Iter<'a, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = MetaSized<Iter<'_, T>[@TraitClause0]>
    parent_clause1 = Sized<&'_ (T)>
    type Item = &'a (T)
    fn next<'_0> = {impl Iterator for Iter<'a, T>[@TraitClause0]}::next<'a, '_0_0, T>[@TraitClause0]
    fn map<B, F, [@TraitClause0]: Sized<B>, [@TraitClause1]: Sized<F>, [@TraitClause2]: Sized<Iter<'a, T>[@TraitClause0]>, [@TraitClause3]: FnMut<F, (&'a (T))>, @TraitClause1_3::parent_clause1::Output = B> = core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::map<'a, T, B, F>[@TraitClause0, @TraitClause0_0, @TraitClause0_1, @TraitClause0_2, @TraitClause0_3]
    fn sum<S, [@TraitClause0]: Sized<S>, [@TraitClause1]: Sized<Iter<'a, T>[@TraitClause0]>, [@TraitClause2]: Sum<S, &'a (T)>> = core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::sum<'a, T, S>[@TraitClause0, @TraitClause0_0, @TraitClause0_1, @TraitClause0_2]
    vtable: {impl Iterator for Iter<'a, T>[@TraitClause0]}::{vtable}<'a, T>[@TraitClause0]
}

// Full name: core::slice::{Slice<T>}::iter
#[lang_item("slice_iter")]
pub fn iter<'_0, T>(@1: &'_0 (Slice<T>)) -> Iter<'_0, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::alloc::Global::{impl Drop for Global}
impl Drop for Global {
    parent_clause0 = MetaSized<Global>
    fn drop<'_0> = {impl Drop for Global}::drop<'_0_0>
    non-dyn-compatible
}

// Full name: alloc::alloc::Global::{impl Drop for Global}::drop
fn {impl Drop for Global}::drop<'_0>(@1: &'_0 mut (Global))

// Full name: alloc::alloc::exchange_malloc
#[lang_item("exchange_malloc")]
unsafe fn exchange_malloc(@1: usize, @2: usize) -> *mut u8

// Full name: alloc::boxed::Box::{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop
fn {impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop<'_0, T, A>(@1: &'_0 mut (alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]))
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::boxed::Box::{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}
impl<T, A> Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
{
    parent_clause0 = MetaSized<alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]>
    fn drop<'_0> = {impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop<'_0_0, T, A>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: alloc::boxed::{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop
pub fn {impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop<'_0, T, A>(@1: &'_0 mut (alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]))
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::boxed::{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}
impl<T, A> Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
{
    parent_clause0 = MetaSized<alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]>
    fn drop<'_0> = {impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop<'_0_0, T, A>[@TraitClause0, @TraitClause1]
    vtable: {impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::{vtable}<T, A>[@TraitClause0, @TraitClause1]
}

// Full name: alloc::vec::Vec
#[lang_item("Vec")]
pub opaque type Vec<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<type_error("removed allocator parameter")>,

// Full name: alloc::slice::{Slice<T>}::into_vec
#[lang_item("slice_into_vec")]
pub fn into_vec<T, A>(@1: alloc::boxed::Box<Slice<T>>[MetaSized<Slice<T>>, @TraitClause1]) -> Vec<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: alloc::string::String::{impl Drop for String}
impl Drop for String {
    parent_clause0 = MetaSized<String>
    fn drop<'_0> = {impl Drop for String}::drop<'_0_0>
    non-dyn-compatible
}

// Full name: alloc::string::String::{impl Drop for String}::drop
fn {impl Drop for String}::drop<'_0>(@1: &'_0 mut (String))

pub fn alloc::string::{String}::len<'_0>(@1: &'_0 (String)) -> usize

pub fn alloc::string::{String}::is_empty<'_0>(@1: &'_0 (String)) -> bool

// Full name: alloc::string::{impl Clone for String}::clone
pub fn {impl Clone for String}::clone<'_0>(@1: &'_0 (String)) -> String

// Full name: alloc::string::{impl Clone for String}
impl Clone for String {
    parent_clause0 = Sized<String>
    fn clone<'_0> = {impl Clone for String}::clone<'_0_0>
    non-dyn-compatible
}

// Full name: alloc::string::ToString
#[lang_item("ToString")]
pub trait ToString<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn to_string<'_0> = alloc::string::ToString::to_string<'_0_0, Self>[Self]
    vtable: alloc::string::ToString::{vtable}
}

#[lang_item("to_string_method")]
pub fn alloc::string::ToString::to_string<'_0, Self>(@1: &'_0 (Self)) -> String
where
    [@TraitClause0]: ToString<Self>,

// Full name: alloc::string::{impl ToString for T}::to_string
pub fn {impl ToString for T}::to_string<'_0, T>(@1: &'_0 (T)) -> String
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Display<T>,

// Full name: alloc::string::{impl ToString for T}
impl<T> ToString for T
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Display<T>,
{
    parent_clause0 = @TraitClause0
    fn to_string<'_0> = {impl ToString for T}::to_string<'_0_0, T>[@TraitClause0, @TraitClause1]
    vtable: {impl ToString for T}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

pub fn alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::len<'_0, T, A>(@1: &'_0 (Vec<T>[@TraitClause0, @TraitClause1])) -> usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::vec::{impl Drop for Vec<T>[@TraitClause0, @TraitClause1]}::drop
pub fn {impl Drop for Vec<T>[@TraitClause0, @TraitClause1]}::drop<'_0, T, A>(@1: &'_0 mut (Vec<T>[@TraitClause0, @TraitClause1]))
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::vec::{impl Drop for Vec<T>[@TraitClause0, @TraitClause1]}
impl<T, A> Drop for Vec<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
{
    parent_clause0 = MetaSized<Vec<T>[@TraitClause0, @TraitClause1]>
    fn drop<'_0> = {impl Drop for Vec<T>[@TraitClause0, @TraitClause1]}::drop<'_0_0, T, A>[@TraitClause0, @TraitClause1]
    vtable: {impl Drop for Vec<T>[@TraitClause0, @TraitClause1]}::{vtable}<T, A>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::Super
trait Super<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn super_method<'_0> = test_crate::Super::super_method<'_0_0, Self, T>[Self]
    vtable: test_crate::Super::{vtable}<T>
}

fn test_crate::Super::super_method<'_0, Self, T>(@1: &'_0 (Self), @2: T) -> i32
where
    [@TraitClause0]: Super<Self, T>,

struct test_crate::Checkable::{vtable}<T> {
  size: usize,
  align: usize,
  drop: fn<'_0>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, T> + _dyn : '_))),
  method_check: fn<'_0>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, T> + _dyn : '_))) -> bool,
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
  super_trait_1: &'static (test_crate::Super::{vtable}<T>),
}

// Full name: test_crate::Checkable
trait Checkable<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Super<Self, T>
    parent_clause2 : [@TraitClause2]: Sized<T>
    fn check<'_0> = test_crate::Checkable::check<'_0_0, Self, T>[Self]
    vtable: test_crate::Checkable::{vtable}<T>
}

fn test_crate::Checkable::check<'_0, Self, T>(@1: &'_0 (Self)) -> bool
where
    [@TraitClause0]: Checkable<Self, T>,

// Full name: test_crate::{impl Super<i32> for i32}::super_method
fn {impl Super<i32> for i32}::super_method<'_0>(@1: &'_0 (i32), @2: i32) -> i32
{
    let @0: i32; // return
    let self@1: &'_ (i32); // arg #1
    let arg@2: i32; // arg #2
    let @3: i32; // anonymous local
    let @4: i32; // anonymous local
    let @5: i32; // anonymous local

    storage_live(@5)
    storage_live(@3)
    @3 := copy (*(self@1))
    storage_live(@4)
    @4 := copy (arg@2)
    @5 := copy (@3) panic.+ copy (@4)
    @0 := move (@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::{impl Super<i32> for i32}
impl Super<i32> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i32>
    fn super_method<'_0> = {impl Super<i32> for i32}::super_method<'_0_0>
    vtable: {impl Super<i32> for i32}::{vtable}
}

// Full name: test_crate::{impl Checkable<i32> for i32}::check
fn {impl Checkable<i32> for i32}::check<'_0>(@1: &'_0 (i32)) -> bool
{
    let @0: bool; // return
    let self@1: &'_ (i32); // arg #1
    let @2: i32; // anonymous local
    let @3: &'_ (i32); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &*(self@1)
    @2 := {impl Super<i32> for i32}::super_method<'_>(move (@3), const (10 : i32))
    storage_dead(@3)
    @0 := move (@2) > const (0 : i32)
    storage_dead(@2)
    return
}

fn {vtable_drop_shim_empty_i32}(@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)))
{
    let ret@0: (); // return
    let self@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)); // arg #1

    ret@0 := ()
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::check::{vtable_method}
fn {impl Checkable<i32> for i32}::check::{vtable_method}<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_))) -> bool
{
    let @0: bool; // return
    let @1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)); // arg #1
    let @2: &'_0 (i32); // anonymous local

    storage_live(@0)
    storage_live(@1)
    storage_live(@2)
    @2 := concretize<&'_0 ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)), &'_0 (i32)>(move (@1))
    @0 := {impl Checkable<i32> for i32}::check<'_0>(move (@2))
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::{vtable}
fn {impl Checkable<i32> for i32}::{vtable}() -> test_crate::Checkable::{vtable}<i32>
{
    let ret@0: test_crate::Checkable::{vtable}<i32>; // return
    let @1: &'static (test_crate::Super::{vtable}<i32>); // anonymous local

    storage_live(@1)
    @1 := &{impl Super<i32> for i32}::{vtable}
    ret@0 := test_crate::Checkable::{vtable} { size: const (4 : usize), align: const (4 : usize), drop: const (@Fun210), method_check: const ({impl Checkable<i32> for i32}::check::{vtable_method}<'_>), super_trait_0: const (Opaque(missing supertrait vtable)), super_trait_1: move (@1) }
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::{vtable}
static {impl Checkable<i32> for i32}::{vtable}: test_crate::Checkable::{vtable}<i32> = {impl Checkable<i32> for i32}::{vtable}()

// Full name: test_crate::{impl Checkable<i32> for i32}
impl Checkable<i32> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = {impl Super<i32> for i32}
    parent_clause2 = Sized<i32>
    fn check<'_0> = {impl Checkable<i32> for i32}::check<'_0_0>
    vtable: {impl Checkable<i32> for i32}::{vtable}
}

struct test_crate::NoParam::{vtable} {
  size: usize,
  align: usize,
  drop: fn<'_0>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_))),
  method_dummy: fn<'_0>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_))),
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::NoParam
trait NoParam<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn dummy<'_0> = test_crate::NoParam::dummy<'_0_0, Self>[Self]
    vtable: test_crate::NoParam::{vtable}
}

fn test_crate::NoParam::dummy<'_0, Self>(@1: &'_0 (Self))
where
    [@TraitClause0]: NoParam<Self>,

// Full name: test_crate::{impl NoParam for i32}::dummy
fn {impl NoParam for i32}::dummy<'_0>(@1: &'_0 (i32))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let @2: (); // anonymous local
    let @3: bool; // anonymous local
    let @4: i32; // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := copy (*(self@1))
    @3 := move (@4) > const (0 : i32)
    if move (@3) {
    }
    else {
        storage_dead(@4)
        panic(core::panicking::panic)
    }
    storage_dead(@4)
    storage_dead(@3)
    storage_dead(@2)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl NoParam for i32}
impl NoParam for i32 {
    parent_clause0 = MetaSized<i32>
    fn dummy<'_0> = {impl NoParam for i32}::dummy<'_0_0>
    vtable: {impl NoParam for i32}::{vtable}
}

// Full name: test_crate::to_dyn_obj
fn to_dyn_obj<'_0, T>(@1: &'_0 (T)) -> &'_0 ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_0))
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: NoParam<T>,
{
    let @0: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // return
    let arg@1: &'_ (T); // arg #1
    let @2: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // anonymous local
    let @3: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // anonymous local
    let @4: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := &*(arg@1)
    @3 := unsize_cast<&'_ (T), &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), @TraitClause1>(move (@4))
    storage_dead(@4)
    @2 := &*(@3)
    @0 := unsize_cast<&'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), NoParam<(dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)>>(move (@2))
    storage_dead(@3)
    storage_dead(@2)
    return
}

struct test_crate::Modifiable::{vtable}<T> {
  size: usize,
  align: usize,
  drop: fn<'_0>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_))),
  method_modify: fn<'_0, '_1>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), &'_0_1 (T)) -> T,
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::Modifiable
trait Modifiable<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn modify<'_0, '_1> = test_crate::Modifiable::modify<'_0_0, '_0_1, Self, T>[Self]
    vtable: test_crate::Modifiable::{vtable}<T>
}

fn test_crate::Modifiable::modify<'_0, '_1, Self, T>(@1: &'_0 mut (Self), @2: &'_1 (T)) -> T
where
    [@TraitClause0]: Modifiable<Self, T>,

// Full name: test_crate::{impl Modifiable<T> for i32}::modify
fn {impl Modifiable<T> for i32}::modify<'_0, '_1, T>(@1: &'_0 mut (i32), @2: &'_1 (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let @0: T; // return
    let self@1: &'_ mut (i32); // arg #1
    let arg@2: &'_ (T); // arg #2
    let @3: i32; // anonymous local
    let @4: &'_ (T); // anonymous local

    storage_live(@3)
    @3 := copy (*(self@1)) panic.+ const (1 : i32)
    *(self@1) := move (@3)
    storage_live(@4)
    @4 := &*(arg@2)
    @0 := @TraitClause1::clone<'_>(move (@4))
    storage_dead(@4)
    return
}

fn {vtable_drop_shim_empty_i32}<T>(@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)))
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let ret@0: (); // return
    let self@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)); // arg #1

    ret@0 := ()
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::modify::{vtable_method}
fn {impl Modifiable<T> for i32}::modify::{vtable_method}<'_0, '_1, T>(@1: &'_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), @2: &'_1 (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let @0: T; // return
    let @1: &'_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)); // arg #1
    let @2: &'_1 (T); // arg #2
    let @3: &'_0 mut (i32); // anonymous local

    storage_live(@0)
    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    @3 := concretize<&'_0 mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), &'_0 mut (i32)>(move (@1))
    @0 := {impl Modifiable<T> for i32}::modify<'_0, '_1, T>[@TraitClause0, @TraitClause1](move (@3), move (@2))
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::{vtable}
fn {impl Modifiable<T> for i32}::{vtable}<T>() -> test_crate::Modifiable::{vtable}<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let ret@0: test_crate::Modifiable::{vtable}<T>; // return

    ret@0 := test_crate::Modifiable::{vtable} { size: const (4 : usize), align: const (4 : usize), drop: const (@Fun209<T>[@TraitClause0, @TraitClause1]), method_modify: const ({impl Modifiable<T> for i32}::modify::{vtable_method}<'_, '_, T>[@TraitClause0, @TraitClause1]), super_trait_0: const (Opaque(missing supertrait vtable)) }
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::{vtable}
static {impl Modifiable<T> for i32}::{vtable}<T>: test_crate::Modifiable::{vtable}<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
 = {impl Modifiable<T> for i32}::{vtable}()

// Full name: test_crate::{impl Modifiable<T> for i32}
impl<T> Modifiable<T> for i32
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    parent_clause0 = MetaSized<i32>
    parent_clause1 = @TraitClause0
    fn modify<'_0, '_1> = {impl Modifiable<T> for i32}::modify<'_0_0, '_0_1, T>[@TraitClause0, @TraitClause1]
    vtable: {impl Modifiable<T> for i32}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::modify_trait_object
fn modify_trait_object<'_0, T>(@1: &'_0 (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let @0: T; // return
    let arg@1: &'_ (T); // arg #1
    let x@2: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)); // local
    let @3: &'_ mut (i32); // anonymous local
    let @4: &'_ mut (i32); // anonymous local
    let @5: i32; // anonymous local
    let @6: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)); // anonymous local
    let @7: &'_ (T); // anonymous local
    let @8: *const test_crate::Modifiable::{vtable}<T>; // anonymous local
    let @9: fn(&'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), &'_ (T)) -> T; // anonymous local

    storage_live(x@2)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := const (199 : i32)
    @4 := &mut @5
    @3 := &mut *(@4)
    x@2 := unsize_cast<&'_ mut (i32), &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, T> + _dyn : '_)), {impl Modifiable<T> for i32}<T>[@TraitClause0, @TraitClause1]>(move (@3))
    storage_dead(@3)
    storage_dead(@4)
    storage_live(@6)
    @6 := &two-phase-mut *(x@2)
    storage_live(@7)
    @7 := &*(arg@1)
    storage_live(@8)
    storage_live(@9)
    @8 := ptr_metadata(move (@6))
    @9 := copy ((*(@8)).3)
    @0 := (move @9)(move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(x@2)
    return
}

// Full name: test_crate::BaseOn
trait BaseOn<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn operate_on<'_0, '_1> = test_crate::BaseOn::operate_on<'_0_0, '_0_1, Self, T>[Self]
    vtable: test_crate::BaseOn::{vtable}<T>
}

fn test_crate::BaseOn::operate_on<'_0, '_1, Self, T>(@1: &'_0 (Self), @2: &'_1 (T))
where
    [@TraitClause0]: BaseOn<Self, T>,

struct test_crate::Both32And64::{vtable} {
  size: usize,
  align: usize,
  drop: fn<'_0>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_))),
  method_both_operate: fn<'_0, '_1, '_2>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)), &'_0_1 (i32), &'_0_2 (i64)),
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
  super_trait_1: &'static (test_crate::BaseOn::{vtable}<i32>),
  super_trait_2: &'static (test_crate::BaseOn::{vtable}<i64>),
}

// Full name: test_crate::Both32And64
trait Both32And64<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: BaseOn<Self, i32>
    parent_clause2 : [@TraitClause2]: BaseOn<Self, i64>
    fn both_operate<'_0, '_1, '_2> = both_operate<'_0_0, '_0_1, '_0_2, Self>[Self]
    vtable: test_crate::Both32And64::{vtable}
}

// Full name: test_crate::Both32And64::both_operate
fn both_operate<'_0, '_1, '_2, Self>(@1: &'_0 (Self), @2: &'_1 (i32), @3: &'_2 (i64))
where
    [@TraitClause0]: Both32And64<Self>,
{
    let @0: (); // return
    let self@1: &'_ (Self); // arg #1
    let t32@2: &'_ (i32); // arg #2
    let t64@3: &'_ (i64); // arg #3
    let @4: (); // anonymous local
    let @5: &'_ (Self); // anonymous local
    let @6: &'_ (i32); // anonymous local
    let @7: (); // anonymous local
    let @8: &'_ (Self); // anonymous local
    let @9: &'_ (i64); // anonymous local

    storage_live(@4)
    storage_live(@5)
    @5 := &*(self@1)
    storage_live(@6)
    @6 := &*(t32@2)
    @4 := @TraitClause0::parent_clause1::operate_on<'_, '_>(move (@5), move (@6))
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@7)
    storage_live(@8)
    @8 := &*(self@1)
    storage_live(@9)
    @9 := &*(t64@3)
    @7 := @TraitClause0::parent_clause2::operate_on<'_, '_>(move (@8), move (@9))
    storage_dead(@9)
    storage_dead(@8)
    storage_dead(@7)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}::operate_on
fn {impl BaseOn<i32> for i32}::operate_on<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let t@2: &'_ (i32); // arg #2
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: i32; // anonymous local
    let @6: i32; // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (*(self@1))
    storage_live(@6)
    @6 := copy (*(t@2))
    @4 := move (@5) > move (@6)
    if move (@4) {
    }
    else {
        storage_dead(@6)
        storage_dead(@5)
        panic(core::panicking::panic)
    }
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}
impl BaseOn<i32> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i32>
    fn operate_on<'_0, '_1> = {impl BaseOn<i32> for i32}::operate_on<'_0_0, '_0_1>
    vtable: {impl BaseOn<i32> for i32}::{vtable}
}

// Full name: test_crate::{impl BaseOn<i64> for i32}::operate_on
fn {impl BaseOn<i64> for i32}::operate_on<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i64))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let t@2: &'_ (i64); // arg #2
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: i64; // anonymous local
    let @6: i32; // anonymous local
    let @7: i64; // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := copy (*(self@1))
    @5 := cast<i32, i64>(move (@6))
    storage_dead(@6)
    storage_live(@7)
    @7 := copy (*(t@2))
    @4 := move (@5) > move (@7)
    if move (@4) {
    }
    else {
        storage_dead(@7)
        storage_dead(@5)
        panic(core::panicking::panic)
    }
    storage_dead(@7)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl BaseOn<i64> for i32}
impl BaseOn<i64> for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i64>
    fn operate_on<'_0, '_1> = {impl BaseOn<i64> for i32}::operate_on<'_0_0, '_0_1>
    vtable: {impl BaseOn<i64> for i32}::{vtable}
}

fn test_crate::{impl Both32And64 for i32}::both_operate<'_0, '_1, '_2>(@1: &'_0 (i32), @2: &'_1 (i32), @3: &'_2 (i64))
{
    let @0: (); // return
    let self@1: &'_ (i32); // arg #1
    let t32@2: &'_ (i32); // arg #2
    let t64@3: &'_ (i64); // arg #3
    let @4: (); // anonymous local
    let @5: &'_ (i32); // anonymous local
    let @6: &'_ (i32); // anonymous local
    let @7: (); // anonymous local
    let @8: &'_ (i32); // anonymous local
    let @9: &'_ (i64); // anonymous local

    storage_live(@4)
    storage_live(@5)
    @5 := &*(self@1)
    storage_live(@6)
    @6 := &*(t32@2)
    @4 := {impl Both32And64 for i32}::parent_clause1::operate_on<'_, '_>(move (@5), move (@6))
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@7)
    storage_live(@8)
    @8 := &*(self@1)
    storage_live(@9)
    @9 := &*(t64@3)
    @7 := {impl Both32And64 for i32}::parent_clause2::operate_on<'_, '_>(move (@8), move (@9))
    storage_dead(@9)
    storage_dead(@8)
    storage_dead(@7)
    @0 := ()
    @0 := ()
    return
}

fn {vtable_drop_shim_empty_i32}(@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)))
{
    let ret@0: (); // return
    let self@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)); // arg #1

    ret@0 := ()
    return
}

// Full name: test_crate::{impl Both32And64 for i32}::{vtable}
fn {impl Both32And64 for i32}::{vtable}() -> test_crate::Both32And64::{vtable}
{
    let ret@0: test_crate::Both32And64::{vtable}; // return
    let @1: &'static (test_crate::BaseOn::{vtable}<i32>); // anonymous local
    let @2: &'static (test_crate::BaseOn::{vtable}<i64>); // anonymous local

    storage_live(@1)
    storage_live(@2)
    @1 := &{impl BaseOn<i32> for i32}::{vtable}
    @2 := &{impl BaseOn<i64> for i32}::{vtable}
    ret@0 := test_crate::Both32And64::{vtable} { size: const (4 : usize), align: const (4 : usize), drop: const (@Fun211), method_both_operate: const (Opaque(shim for default methods aren't yet supported)), super_trait_0: const (Opaque(missing supertrait vtable)), super_trait_1: move (@1), super_trait_2: move (@2) }
    return
}

// Full name: test_crate::{impl Both32And64 for i32}::{vtable}
static {impl Both32And64 for i32}::{vtable}: test_crate::Both32And64::{vtable} = {impl Both32And64 for i32}::{vtable}()

// Full name: test_crate::{impl Both32And64 for i32}
impl Both32And64 for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = {impl BaseOn<i32> for i32}
    parent_clause2 = {impl BaseOn<i64> for i32}
    fn both_operate<'_0, '_1, '_2> = test_crate::{impl Both32And64 for i32}::both_operate<'_0_0, '_0_1, '_0_2>
    vtable: {impl Both32And64 for i32}::{vtable}
}

// Full name: test_crate::Alias
trait Alias<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Both32And64<Self>
    vtable: test_crate::Alias::{vtable}
}

struct test_crate::LifetimeTrait::{vtable}<Ty0> {
  size: usize,
  align: usize,
  drop: fn<'_0>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0))),
  method_lifetime_method: fn<'a, '_1>(&'_0_1 ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0)), &'a (LifetimeTrait<(dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0)>::Ty)) -> &'a (LifetimeTrait<(dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = Ty0)>::Ty),
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::LifetimeTrait
trait LifetimeTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Ty>
    type Ty
    fn lifetime_method<'a, '_1> = test_crate::LifetimeTrait::lifetime_method<'a, '_0_1, Self>[Self]
    vtable: test_crate::LifetimeTrait::{vtable}<Self::Ty>
}

fn test_crate::LifetimeTrait::lifetime_method<'a, '_1, Self>(@1: &'_1 (Self), @2: &'a (@TraitClause0::Ty)) -> &'a (@TraitClause0::Ty)
where
    [@TraitClause0]: LifetimeTrait<Self>,

// Full name: test_crate::{impl LifetimeTrait for i32}::lifetime_method
fn {impl LifetimeTrait for i32}::lifetime_method<'a, '_1>(@1: &'_1 (i32), @2: &'a (i32)) -> &'a (i32)
{
    let @0: &'_ (i32); // return
    let self@1: &'_ (i32); // arg #1
    let arg@2: &'_ (i32); // arg #2
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: i32; // anonymous local
    let @6: i32; // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (*(self@1))
    storage_live(@6)
    @6 := copy (*(arg@2))
    @4 := move (@5) > move (@6)
    if move (@4) {
    }
    else {
        storage_dead(@6)
        storage_dead(@5)
        panic(core::panicking::panic)
    }
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    @0 := copy (arg@2)
    return
}

// Full name: test_crate::{impl LifetimeTrait for i32}
impl LifetimeTrait for i32 {
    parent_clause0 = MetaSized<i32>
    parent_clause1 = Sized<i32>
    type Ty = i32
    fn lifetime_method<'a, '_1> = {impl LifetimeTrait for i32}::lifetime_method<'a, '_0_1>
    vtable: {impl LifetimeTrait for i32}::{vtable}
}

// Full name: test_crate::use_lifetime_trait
fn use_lifetime_trait<'a, '_1>(@1: &'_1 ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_1 + @TraitClause1_0::Ty = i32)), @2: &'a (i32)) -> &'a (i32)
{
    let @0: &'_ (i32); // return
    let x@1: &'_ ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = i32)); // arg #1
    let y@2: &'_ (i32); // arg #2
    let @3: &'_ (i32); // anonymous local
    let @4: &'_ ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = i32)); // anonymous local
    let @5: &'_ (i32); // anonymous local
    let @6: *const test_crate::LifetimeTrait::{vtable}<i32>; // anonymous local
    let @7: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: LifetimeTrait<_dyn> + _dyn : '_ + @TraitClause1_0::Ty = i32)), &'_ (i32)) -> &'_ (i32); // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := &*(x@1)
    storage_live(@5)
    @5 := &*(y@2)
    storage_live(@6)
    storage_live(@7)
    @6 := ptr_metadata(move (@4))
    @7 := copy ((*(@6)).3)
    @3 := (move @7)(move (@4), move (@5))
    @0 := &*(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::use_alias
fn use_alias<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_0)))
{
    let @0: (); // return
    let x@1: &'_ ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)); // arg #1
    let @2: (); // anonymous local
    let @3: &'_ ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)); // anonymous local
    let @4: &'_ (i32); // anonymous local
    let @5: &'_ (i32); // anonymous local
    let @6: i32; // anonymous local
    let @7: &'_ (i64); // anonymous local
    let @8: &'_ (i64); // anonymous local
    let @9: i64; // anonymous local
    let @10: *const test_crate::Both32And64::{vtable}; // anonymous local
    let @11: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)), &'_ (i32), &'_ (i64)); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := const (100 : i32)
    @5 := &@6
    @4 := &*(@5)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    @9 := const (200 : i64)
    @8 := &@9
    @7 := &*(@8)
    storage_live(@10)
    storage_live(@11)
    @10 := ptr_metadata(move (@3))
    @11 := copy ((*(@10)).3)
    @2 := (move @11)(move (@3), move (@4), move (@7))
    storage_dead(@7)
    storage_dead(@4)
    storage_dead(@3)
    storage_dead(@9)
    storage_dead(@8)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@2)
    @0 := ()
    @0 := ()
    return
}

struct test_crate::DropTuple::{vtable} {
  size: usize,
  align: usize,
  drop: fn<'_0>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_))),
  method_process_tuple: fn<'_0>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)), (String, Vec<i32>[Sized<i32>, Sized<Global>])) -> usize,
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::DropTuple
trait DropTuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn process_tuple<'_0> = test_crate::DropTuple::process_tuple<'_0_0, Self>[Self]
    vtable: test_crate::DropTuple::{vtable}
}

fn test_crate::DropTuple::process_tuple<'_0, Self>(@1: &'_0 (Self), @2: (String, Vec<i32>[Sized<i32>, Sized<Global>])) -> usize
where
    [@TraitClause0]: DropTuple<Self>,

// Full name: test_crate::{impl DropTuple for i32}::process_tuple
fn {impl DropTuple for i32}::process_tuple<'_0>(@1: &'_0 (i32), @2: (String, Vec<i32>[Sized<i32>, Sized<Global>])) -> usize
{
    let @0: usize; // return
    let self@1: &'_ (i32); // arg #1
    let t@2: (String, Vec<i32>[Sized<i32>, Sized<Global>]); // arg #2
    let @3: usize; // anonymous local
    let @4: &'_ (String); // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ (Vec<i32>[Sized<i32>, Sized<Global>]); // anonymous local
    let @7: usize; // anonymous local

    storage_live(@7)
    storage_live(@3)
    storage_live(@4)
    @4 := &(t@2).0
    @3 := alloc::string::{String}::len<'_>(move (@4))
    storage_dead(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &(t@2).1
    @5 := alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::len<'_, i32, Global>[Sized<i32>, Sized<Global>](move (@6))
    storage_dead(@6)
    @7 := copy (@3) panic.+ copy (@5)
    @0 := move (@7)
    storage_dead(@5)
    storage_dead(@3)
    drop[Drop<(String, Vec<i32>[Sized<i32>, Sized<Global>])>] t@2
    return
}

fn {vtable_drop_shim_empty_i32}(@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)))
{
    let ret@0: (); // return
    let self@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)); // arg #1

    ret@0 := ()
    return
}

// Full name: test_crate::{impl DropTuple for i32}::process_tuple::{vtable_method}
fn {impl DropTuple for i32}::process_tuple::{vtable_method}<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)), @2: (String, Vec<i32>[Sized<i32>, Sized<Global>])) -> usize
{
    let @0: usize; // return
    let @1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)); // arg #1
    let @2: (String, Vec<i32>[Sized<i32>, Sized<Global>]); // arg #2
    let @3: &'_0 (i32); // anonymous local

    storage_live(@0)
    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    @3 := concretize<&'_0 ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)), &'_0 (i32)>(move (@1))
    @0 := {impl DropTuple for i32}::process_tuple<'_0>(move (@3), move (@2))
    return
}

// Full name: test_crate::{impl DropTuple for i32}::{vtable}
fn {impl DropTuple for i32}::{vtable}() -> test_crate::DropTuple::{vtable}
{
    let ret@0: test_crate::DropTuple::{vtable}; // return

    ret@0 := test_crate::DropTuple::{vtable} { size: const (4 : usize), align: const (4 : usize), drop: const (@Fun212), method_process_tuple: const ({impl DropTuple for i32}::process_tuple::{vtable_method}<'_>), super_trait_0: const (Opaque(missing supertrait vtable)) }
    return
}

// Full name: test_crate::{impl DropTuple for i32}::{vtable}
static {impl DropTuple for i32}::{vtable}: test_crate::DropTuple::{vtable} = {impl DropTuple for i32}::{vtable}()

// Full name: test_crate::{impl DropTuple for i32}
impl DropTuple for i32 {
    parent_clause0 = MetaSized<i32>
    fn process_tuple<'_0> = {impl DropTuple for i32}::process_tuple<'_0_0>
    vtable: {impl DropTuple for i32}::{vtable}
}

// Full name: test_crate::use_drop_tuple
fn use_drop_tuple<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_0))) -> usize
{
    let @0: usize; // return
    let x@1: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)); // arg #1
    let @2: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)); // anonymous local
    let @3: (String, Vec<i32>[Sized<i32>, Sized<Global>]); // anonymous local
    let @4: String; // anonymous local
    let @5: &'_ (Str); // anonymous local
    let @6: &'_ (Str); // anonymous local
    let @7: Vec<i32>[Sized<i32>, Sized<Global>]; // anonymous local
    let @8: alloc::boxed::Box<Slice<i32>>[MetaSized<Slice<i32>>, Sized<Global>]; // anonymous local
    let @9: alloc::boxed::Box<Array<i32, 3 : usize>>[MetaSized<Array<i32, 3 : usize>>, Sized<Global>]; // anonymous local
    let @10: alloc::boxed::Box<Array<i32, 3 : usize>>[MetaSized<Array<i32, 3 : usize>>, Sized<Global>]; // anonymous local
    let @11: *const test_crate::DropTuple::{vtable}; // anonymous local
    let @12: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)), (String, Vec<i32>[Sized<i32>, Sized<Global>])) -> usize; // anonymous local
    let @13: Array<i32, 3 : usize>; // anonymous local

    storage_live(@13)
    storage_live(@2)
    @2 := &*(x@1)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := const ("hello")
    @5 := &*(@6)
    @4 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@5))
    storage_dead(@5)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    @13 := [const (1 : i32), const (2 : i32), const (3 : i32)]
    storage_live(@10)
    @10 := @BoxNew<Array<i32, 3 : usize>>[MetaSized<Array<i32, 3 : usize>>, Sized<Global>](move (@13))
    @9 := move (@10)
    @8 := unsize_cast<alloc::boxed::Box<Array<i32, 3 : usize>>[MetaSized<Array<i32, 3 : usize>>, Sized<Global>], alloc::boxed::Box<Slice<i32>>[MetaSized<Slice<i32>>, Sized<Global>], 3 : usize>(move (@9))
    drop[{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<Array<i32, 3 : usize>, Global>[MetaSized<Array<i32, 3 : usize>>, Sized<Global>]] @9
    drop[{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<Array<i32, 3 : usize>, Global>[MetaSized<Array<i32, 3 : usize>>, Sized<Global>]] @10
    storage_dead(@10)
    storage_dead(@9)
    @7 := into_vec<i32, Global>[Sized<i32>, Sized<Global>](move (@8))
    storage_dead(@8)
    @3 := (move (@4), move (@7))
    drop[{impl Drop for Vec<T>[@TraitClause0, @TraitClause1]}<i32, Global>[Sized<i32>, Sized<Global>]] @7
    storage_dead(@7)
    drop[{impl Drop for String}] @4
    storage_dead(@4)
    storage_live(@11)
    storage_live(@12)
    @11 := ptr_metadata(move (@2))
    @12 := copy ((*(@11)).3)
    @0 := (move @12)(move (@2), move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_dead(@6)
    return
}

struct test_crate::DropArray::{vtable} {
  size: usize,
  align: usize,
  drop: fn<'_0>(&'_0_0 mut ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_))),
  method_process_array: fn<'_0>(&'_0_0 ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)), Array<String, 3 : usize>) -> usize,
  super_trait_0: &'static (core::marker::MetaSized::{vtable}),
}

// Full name: test_crate::DropArray
trait DropArray<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn process_array<'_0> = test_crate::DropArray::process_array<'_0_0, Self>[Self]
    vtable: test_crate::DropArray::{vtable}
}

fn test_crate::DropArray::process_array<'_0, Self>(@1: &'_0 (Self), @2: Array<String, 3 : usize>) -> usize
where
    [@TraitClause0]: DropArray<Self>,

// Full name: test_crate::{impl DropArray for i32}::process_array::closure
struct closure {}

// Full name: test_crate::{impl DropArray for i32}::process_array::{impl FnMut<(&'_ (String))> for closure}::call_mut
fn {impl FnMut<(&'_ (String))> for closure}::call_mut<'_0>(@1: &'_0 mut (closure), @2: (&'_ (String))) -> usize
{
    let @0: usize; // return
    let @1: &'_ mut (closure); // arg #1
    let tupled_args@2: (&'_ (String)); // arg #2
    let s@3: &'_ (String); // local
    let @4: &'_ (String); // anonymous local

    storage_live(s@3)
    s@3 := move ((tupled_args@2).0)
    storage_live(@4)
    @4 := &*(s@3)
    @0 := alloc::string::{String}::len<'_>(move (@4))
    storage_dead(@4)
    return
}

// Full name: test_crate::{impl DropArray for i32}::process_array::{impl FnOnce<(&'_ (String))> for closure}::call_once
fn {impl FnOnce<(&'_ (String))> for closure}::call_once(@1: closure, @2: (&'_ (String))) -> usize
{
    let @0: usize; // return
    let @1: closure; // arg #1
    let @2: (&'_ (String)); // arg #2
    let @3: &'_ mut (closure); // anonymous local

    storage_live(@3)
    @3 := &mut @1
    @0 := {impl FnMut<(&'_ (String))> for closure}::call_mut<'_>(move (@3), move (@2))
    drop[Drop<closure>] @1
    return
}

// Full name: test_crate::{impl DropArray for i32}::process_array::{impl FnOnce<(&'_ (String))> for closure}
impl FnOnce<(&'_ (String))> for closure {
    parent_clause0 = MetaSized<closure>
    parent_clause1 = Sized<(&'_ (String))>
    parent_clause2 = Tuple<(&'_ (String))>
    parent_clause3 = Sized<usize>
    type Output = usize
    fn call_once = {impl FnOnce<(&'_ (String))> for closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::{impl DropArray for i32}::process_array::{impl FnMut<(&'_ (String))> for closure}
impl FnMut<(&'_ (String))> for closure {
    parent_clause0 = MetaSized<closure>
    parent_clause1 = {impl FnOnce<(&'_ (String))> for closure}
    parent_clause2 = Sized<(&'_ (String))>
    parent_clause3 = Tuple<(&'_ (String))>
    fn call_mut<'_0> = {impl FnMut<(&'_ (String))> for closure}::call_mut<'_0_0>
    non-dyn-compatible
}

// Full name: test_crate::{impl DropArray for i32}::process_array
fn {impl DropArray for i32}::process_array<'_0>(@1: &'_0 (i32), @2: Array<String, 3 : usize>) -> usize
{
    let @0: usize; // return
    let self@1: &'_ (i32); // arg #1
    let arr@2: Array<String, 3 : usize>; // arg #2
    let @3: Map<Iter<'_, String>[Sized<String>], closure>[Sized<Iter<'_, String>[Sized<String>]>, Sized<closure>]; // anonymous local
    let @4: Iter<'_, String>[Sized<String>]; // anonymous local
    let @5: &'_ (Slice<String>); // anonymous local
    let @6: &'_ (Array<String, 3 : usize>); // anonymous local
    let @7: closure; // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &arr@2
    @5 := @ArrayToSliceShared<'_, String, 3 : usize>(move (@6))
    storage_dead(@6)
    @4 := iter<'_, String>[Sized<String>](move (@5))
    storage_dead(@5)
    storage_live(@7)
    @7 := closure {  }
    @3 := core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::map<'_, String, usize, closure>[Sized<String>, Sized<usize>, Sized<closure>, Sized<Iter<'_, String>[Sized<String>]>, {impl FnMut<(&'_ (String))> for closure}](move (@4), move (@7))
    storage_dead(@7)
    storage_dead(@4)
    @0 := core::iter::adapters::map::{impl Iterator for Map<I, F>[@TraitClause0, @TraitClause1]}::sum<usize, Iter<'_, String>[Sized<String>], closure, usize>[Sized<Iter<'_, String>[Sized<String>]>, Sized<closure>, {impl Iterator for Iter<'a, T>[@TraitClause0]}<'_, String>[Sized<String>], {impl FnMut<(&'_ (String))> for closure}, Sized<usize>, Sized<usize>, Sized<Map<Iter<'_, String>[Sized<String>], closure>[Sized<Iter<'_, String>[Sized<String>]>, Sized<closure>]>, {impl Sum<usize> for usize}](move (@3))
    storage_dead(@3)
    drop[Drop<Array<String, 3 : usize>>] arr@2
    return
}

fn {vtable_drop_shim_empty_i32}(@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)))
{
    let ret@0: (); // return
    let self@1: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)); // arg #1

    ret@0 := ()
    return
}

// Full name: test_crate::{impl DropArray for i32}::process_array::{vtable_method}
fn {impl DropArray for i32}::process_array::{vtable_method}<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)), @2: Array<String, 3 : usize>) -> usize
{
    let @0: usize; // return
    let @1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)); // arg #1
    let @2: Array<String, 3 : usize>; // arg #2
    let @3: &'_0 (i32); // anonymous local

    storage_live(@0)
    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    @3 := concretize<&'_0 ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)), &'_0 (i32)>(move (@1))
    @0 := {impl DropArray for i32}::process_array<'_0>(move (@3), move (@2))
    return
}

// Full name: test_crate::{impl DropArray for i32}::{vtable}
fn {impl DropArray for i32}::{vtable}() -> test_crate::DropArray::{vtable}
{
    let ret@0: test_crate::DropArray::{vtable}; // return

    ret@0 := test_crate::DropArray::{vtable} { size: const (4 : usize), align: const (4 : usize), drop: const (@Fun213), method_process_array: const ({impl DropArray for i32}::process_array::{vtable_method}<'_>), super_trait_0: const (Opaque(missing supertrait vtable)) }
    return
}

// Full name: test_crate::{impl DropArray for i32}::{vtable}
static {impl DropArray for i32}::{vtable}: test_crate::DropArray::{vtable} = {impl DropArray for i32}::{vtable}()

// Full name: test_crate::{impl DropArray for i32}
impl DropArray for i32 {
    parent_clause0 = MetaSized<i32>
    fn process_array<'_0> = {impl DropArray for i32}::process_array<'_0_0>
    vtable: {impl DropArray for i32}::{vtable}
}

// Full name: test_crate::use_drop_array
fn use_drop_array<'_0>(@1: &'_0 ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_0))) -> usize
{
    let @0: usize; // return
    let x@1: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)); // arg #1
    let @2: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)); // anonymous local
    let @3: Array<String, 3 : usize>; // anonymous local
    let @4: String; // anonymous local
    let @5: &'_ (Str); // anonymous local
    let @6: &'_ (Str); // anonymous local
    let @7: String; // anonymous local
    let @8: &'_ (Str); // anonymous local
    let @9: &'_ (Str); // anonymous local
    let @10: String; // anonymous local
    let @11: &'_ (Str); // anonymous local
    let @12: &'_ (Str); // anonymous local
    let @13: *const test_crate::DropArray::{vtable}; // anonymous local
    let @14: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)), Array<String, 3 : usize>) -> usize; // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := const ("a")
    @5 := &*(@6)
    @4 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@5))
    storage_dead(@5)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    @9 := const ("bb")
    @8 := &*(@9)
    @7 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@8))
    storage_dead(@8)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := const ("ccc")
    @11 := &*(@12)
    @10 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@11))
    storage_dead(@11)
    @3 := [move (@4), move (@7), move (@10)]
    drop[{impl Drop for String}] @10
    storage_dead(@10)
    drop[{impl Drop for String}] @7
    storage_dead(@7)
    drop[{impl Drop for String}] @4
    storage_dead(@4)
    storage_live(@13)
    storage_live(@14)
    @13 := ptr_metadata(move (@2))
    @14 := copy ((*(@13)).3)
    @0 := (move @14)(move (@2), move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_dead(@12)
    storage_dead(@9)
    storage_dead(@6)
    return
}

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let x@1: &'_ ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)); // local
    let @2: &'_ (i32); // anonymous local
    let @3: &'_ (i32); // anonymous local
    let @4: i32; // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: &'_ ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)); // anonymous local
    let y@8: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, i32> + _dyn : '_)); // local
    let @9: &'_ mut (i32); // anonymous local
    let @10: &'_ mut (i32); // anonymous local
    let @11: i32; // anonymous local
    let @12: (); // anonymous local
    let @13: bool; // anonymous local
    let @14: &'_ (String); // anonymous local
    let @15: String; // anonymous local
    let @16: &'_ (String); // anonymous local
    let @17: &'_ (String); // anonymous local
    let @18: String; // anonymous local
    let @19: &'_ (Str); // anonymous local
    let @20: &'_ (Str); // anonymous local
    let @21: (); // anonymous local
    let @22: (&'_ (i32), &'_ (i32)); // anonymous local
    let @23: &'_ (i32); // anonymous local
    let @24: i32; // anonymous local
    let @25: &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, i32> + _dyn : '_)); // anonymous local
    let @26: &'_ (i32); // anonymous local
    let @27: &'_ mut (i32); // anonymous local
    let @28: i32; // anonymous local
    let @29: &'_ (i32); // anonymous local
    let @30: i32; // anonymous local
    let left_val@31: &'_ (i32); // local
    let right_val@32: &'_ (i32); // local
    let @33: bool; // anonymous local
    let @34: i32; // anonymous local
    let @35: i32; // anonymous local
    let kind@36: AssertKind; // local
    let @37: AssertKind; // anonymous local
    let @38: &'_ (i32); // anonymous local
    let @39: &'_ (i32); // anonymous local
    let @40: &'_ (i32); // anonymous local
    let @41: &'_ (i32); // anonymous local
    let @42: Option<Arguments<'_>>[Sized<Arguments<'_>>]; // anonymous local
    let z@43: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // local
    let @44: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // anonymous local
    let @45: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // anonymous local
    let @46: &'_ (i32); // anonymous local
    let @47: &'_ (i32); // anonymous local
    let @48: i32; // anonymous local
    let @49: (); // anonymous local
    let @50: &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)); // anonymous local
    let a@51: &'_ ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)); // local
    let @52: &'_ (i32); // anonymous local
    let @53: &'_ (i32); // anonymous local
    let @54: i32; // anonymous local
    let @55: (); // anonymous local
    let @56: &'_ ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)); // anonymous local
    let @57: &'_ (i32); // anonymous local
    let @58: &'_ (i32); // anonymous local
    let @59: i32; // anonymous local
    let @60: &'_ (i64); // anonymous local
    let @61: &'_ (i64); // anonymous local
    let @62: i64; // anonymous local
    let tuple_handler@63: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)); // local
    let @64: &'_ (i32); // anonymous local
    let @65: &'_ (i32); // anonymous local
    let @66: i32; // anonymous local
    let @67: (); // anonymous local
    let @68: (&'_ (usize), &'_ (usize)); // anonymous local
    let @69: &'_ (usize); // anonymous local
    let @70: usize; // anonymous local
    let @71: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)); // anonymous local
    let @72: (String, Vec<i32>[Sized<i32>, Sized<Global>]); // anonymous local
    let @73: String; // anonymous local
    let @74: &'_ (Str); // anonymous local
    let @75: &'_ (Str); // anonymous local
    let @76: Vec<i32>[Sized<i32>, Sized<Global>]; // anonymous local
    let @77: alloc::boxed::Box<Slice<i32>>[MetaSized<Slice<i32>>, Sized<Global>]; // anonymous local
    let @78: alloc::boxed::Box<Array<i32, 2 : usize>>[MetaSized<Array<i32, 2 : usize>>, Sized<Global>]; // anonymous local
    let @79: alloc::boxed::Box<Array<i32, 2 : usize>>[MetaSized<Array<i32, 2 : usize>>, Sized<Global>]; // anonymous local
    let @80: &'_ (usize); // anonymous local
    let @81: usize; // anonymous local
    let left_val@82: &'_ (usize); // local
    let right_val@83: &'_ (usize); // local
    let @84: bool; // anonymous local
    let @85: usize; // anonymous local
    let @86: usize; // anonymous local
    let kind@87: AssertKind; // local
    let @88: AssertKind; // anonymous local
    let @89: &'_ (usize); // anonymous local
    let @90: &'_ (usize); // anonymous local
    let @91: &'_ (usize); // anonymous local
    let @92: &'_ (usize); // anonymous local
    let @93: Option<Arguments<'_>>[Sized<Arguments<'_>>]; // anonymous local
    let array_handler@94: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)); // local
    let @95: &'_ (i32); // anonymous local
    let @96: &'_ (i32); // anonymous local
    let @97: i32; // anonymous local
    let @98: (); // anonymous local
    let @99: (&'_ (usize), &'_ (usize)); // anonymous local
    let @100: &'_ (usize); // anonymous local
    let @101: usize; // anonymous local
    let @102: &'_ ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)); // anonymous local
    let @103: Array<String, 3 : usize>; // anonymous local
    let @104: String; // anonymous local
    let @105: &'_ (Str); // anonymous local
    let @106: &'_ (Str); // anonymous local
    let @107: String; // anonymous local
    let @108: &'_ (Str); // anonymous local
    let @109: &'_ (Str); // anonymous local
    let @110: String; // anonymous local
    let @111: &'_ (Str); // anonymous local
    let @112: &'_ (Str); // anonymous local
    let @113: &'_ (usize); // anonymous local
    let @114: usize; // anonymous local
    let left_val@115: &'_ (usize); // local
    let right_val@116: &'_ (usize); // local
    let @117: bool; // anonymous local
    let @118: usize; // anonymous local
    let @119: usize; // anonymous local
    let kind@120: AssertKind; // local
    let @121: AssertKind; // anonymous local
    let @122: &'_ (usize); // anonymous local
    let @123: &'_ (usize); // anonymous local
    let @124: &'_ (usize); // anonymous local
    let @125: &'_ (usize); // anonymous local
    let @126: Option<Arguments<'_>>[Sized<Arguments<'_>>]; // anonymous local
    let @127: *const test_crate::Checkable::{vtable}<i32>; // anonymous local
    let @128: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_))) -> bool; // anonymous local
    let @129: *const test_crate::Modifiable::{vtable}<i32>; // anonymous local
    let @130: fn(&'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, i32> + _dyn : '_)), &'_ (i32)) -> i32; // anonymous local
    let @131: *const test_crate::NoParam::{vtable}; // anonymous local
    let @132: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_))); // anonymous local
    let @133: *const test_crate::Both32And64::{vtable}; // anonymous local
    let @134: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)), &'_ (i32), &'_ (i64)); // anonymous local
    let @135: *const test_crate::DropTuple::{vtable}; // anonymous local
    let @136: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)), (String, Vec<i32>[Sized<i32>, Sized<Global>])) -> usize; // anonymous local
    let @137: *const test_crate::DropArray::{vtable}; // anonymous local
    let @138: fn(&'_ ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)), Array<String, 3 : usize>) -> usize; // anonymous local
    let @139: Array<i32, 2 : usize>; // anonymous local

    storage_live(@21)
    storage_live(@22)
    storage_live(@23)
    storage_live(@24)
    storage_live(@25)
    storage_live(@26)
    storage_live(@27)
    storage_live(@28)
    storage_live(@29)
    storage_live(@30)
    storage_live(left_val@31)
    storage_live(right_val@32)
    storage_live(@33)
    storage_live(@34)
    storage_live(@35)
    storage_live(kind@36)
    storage_live(@37)
    storage_live(@38)
    storage_live(@39)
    storage_live(@40)
    storage_live(@41)
    storage_live(@42)
    storage_live(z@43)
    storage_live(@44)
    storage_live(@45)
    storage_live(@46)
    storage_live(@47)
    storage_live(@48)
    storage_live(@49)
    storage_live(@50)
    storage_live(a@51)
    storage_live(@52)
    storage_live(@53)
    storage_live(@54)
    storage_live(@55)
    storage_live(@56)
    storage_live(@57)
    storage_live(@58)
    storage_live(@59)
    storage_live(@60)
    storage_live(@61)
    storage_live(@62)
    storage_live(tuple_handler@63)
    storage_live(@64)
    storage_live(@65)
    storage_live(@66)
    storage_live(@67)
    storage_live(@68)
    storage_live(@69)
    storage_live(@70)
    storage_live(@71)
    storage_live(@72)
    storage_live(@73)
    storage_live(@74)
    storage_live(@75)
    storage_live(@76)
    storage_live(@77)
    storage_live(@78)
    storage_live(@79)
    storage_live(@80)
    storage_live(@81)
    storage_live(left_val@82)
    storage_live(right_val@83)
    storage_live(@84)
    storage_live(@85)
    storage_live(@86)
    storage_live(kind@87)
    storage_live(@88)
    storage_live(@89)
    storage_live(@90)
    storage_live(@91)
    storage_live(@92)
    storage_live(@93)
    storage_live(array_handler@94)
    storage_live(@95)
    storage_live(@96)
    storage_live(@97)
    storage_live(@98)
    storage_live(@99)
    storage_live(@100)
    storage_live(@101)
    storage_live(@102)
    storage_live(@103)
    storage_live(@104)
    storage_live(@105)
    storage_live(@106)
    storage_live(@107)
    storage_live(@108)
    storage_live(@109)
    storage_live(@110)
    storage_live(@111)
    storage_live(@112)
    storage_live(@113)
    storage_live(@114)
    storage_live(left_val@115)
    storage_live(right_val@116)
    storage_live(@117)
    storage_live(@118)
    storage_live(@119)
    storage_live(kind@120)
    storage_live(@121)
    storage_live(@122)
    storage_live(@123)
    storage_live(@124)
    storage_live(@125)
    storage_live(@126)
    storage_live(@129)
    storage_live(@130)
    storage_live(@131)
    storage_live(@132)
    storage_live(@133)
    storage_live(@134)
    storage_live(@135)
    storage_live(@136)
    storage_live(@137)
    storage_live(@138)
    storage_live(@139)
    storage_live(x@1)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := const (42 : i32)
    @3 := &@4
    @2 := &*(@3)
    x@1 := unsize_cast<&'_ (i32), &'_ ((dyn exists<_dyn> [@TraitClause0]: Checkable<_dyn, i32> + _dyn : '_)), {impl Checkable<i32> for i32}>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &*(x@1)
    storage_live(@127)
    storage_live(@128)
    @127 := ptr_metadata(move (@7))
    @128 := copy ((*(@127)).3)
    @6 := (move @128)(move (@7))
    if move (@6) {
    }
    else {
        storage_dead(@7)
        panic(core::panicking::panic)
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_dead(@5)
    storage_live(y@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    @11 := const (99 : i32)
    @10 := &mut @11
    @9 := &mut *(@10)
    y@8 := unsize_cast<&'_ mut (i32), &'_ mut ((dyn exists<_dyn> [@TraitClause0]: Modifiable<_dyn, i32> + _dyn : '_)), {impl Modifiable<T> for i32}<i32>[Sized<i32>, {impl Clone for i32}]>(move (@9))
    storage_dead(@9)
    storage_dead(@10)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    @20 := const ("Hello")
    @19 := &*(@20)
    @18 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@19))
    storage_dead(@19)
    @17 := &@18
    @16 := &*(@17)
    @15 := modify_trait_object<'_, String>[Sized<String>, {impl Clone for String}](move (@16))
    @14 := &@15
    storage_dead(@16)
    @13 := alloc::string::{String}::is_empty<'_>(move (@14))
    if move (@13) {
    }
    else {
        storage_dead(@14)
        drop[{impl Drop for String}] @15
        drop[{impl Drop for String}] @18
        storage_dead(@20)
        storage_dead(@18)
        storage_dead(@17)
        storage_dead(@15)
        storage_dead(@13)
        storage_dead(@12)
        storage_live(@21)
        storage_live(@22)
        storage_live(@23)
        storage_live(@24)
        storage_live(@25)
        @25 := &two-phase-mut *(y@8)
        storage_live(@26)
        storage_live(@27)
        storage_live(@28)
        @28 := const (100 : i32)
        @27 := &mut @28
        @26 := &*(@27)
        storage_live(@129)
        storage_live(@130)
        @129 := ptr_metadata(move (@25))
        @130 := copy ((*(@129)).3)
        @24 := (move @130)(move (@25), move (@26))
        storage_dead(@26)
        storage_dead(@25)
        @23 := &@24
        storage_live(@29)
        storage_live(@30)
        @30 := const (100 : i32)
        @29 := &@30
        @22 := (move (@23), move (@29))
        storage_dead(@29)
        storage_dead(@23)
        storage_live(left_val@31)
        left_val@31 := copy ((@22).0)
        storage_live(right_val@32)
        right_val@32 := copy ((@22).1)
        storage_live(@33)
        storage_live(@34)
        @34 := copy (*(left_val@31))
        storage_live(@35)
        @35 := copy (*(right_val@32))
        @33 := move (@34) == move (@35)
        if move (@33) {
        }
        else {
            storage_dead(@35)
            storage_dead(@34)
            storage_live(kind@36)
            kind@36 := AssertKind::Eq {  }
            storage_live(@37)
            @37 := move (kind@36)
            storage_live(@38)
            storage_live(@39)
            @39 := &*(left_val@31)
            @38 := &*(@39)
            storage_live(@40)
            storage_live(@41)
            @41 := &*(right_val@32)
            @40 := &*(@41)
            storage_live(@42)
            @42 := Option::None {  }
            panic(core::panicking::assert_failed)
        }
        storage_dead(@35)
        storage_dead(@34)
        storage_dead(@33)
        storage_dead(right_val@32)
        storage_dead(left_val@31)
        storage_dead(@30)
        storage_dead(@28)
        storage_dead(@27)
        storage_dead(@24)
        storage_dead(@22)
        storage_dead(@21)
        storage_live(z@43)
        storage_live(@44)
        storage_live(@45)
        storage_live(@46)
        storage_live(@47)
        storage_live(@48)
        @48 := const (42 : i32)
        @47 := &@48
        @46 := &*(@47)
        @45 := to_dyn_obj<'_, i32>[Sized<i32>, {impl NoParam for i32}](move (@46))
        @44 := &*(@45)
        z@43 := unsize_cast<&'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), &'_ ((dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)), NoParam<(dyn exists<_dyn> [@TraitClause0]: NoParam<_dyn> + _dyn : '_)>>(move (@44))
        storage_dead(@46)
        storage_dead(@44)
        storage_dead(@48)
        storage_dead(@47)
        storage_dead(@45)
        storage_live(@49)
        storage_live(@50)
        @50 := &*(z@43)
        storage_live(@131)
        storage_live(@132)
        @131 := ptr_metadata(move (@50))
        @132 := copy ((*(@131)).3)
        @49 := (move @132)(move (@50))
        storage_dead(@50)
        storage_dead(@49)
        storage_live(a@51)
        storage_live(@52)
        storage_live(@53)
        storage_live(@54)
        @54 := const (42 : i32)
        @53 := &@54
        @52 := &*(@53)
        a@51 := unsize_cast<&'_ (i32), &'_ ((dyn exists<_dyn> [@TraitClause0]: Both32And64<_dyn> + _dyn : '_)), {impl Both32And64 for i32}>(move (@52))
        storage_dead(@52)
        storage_dead(@53)
        storage_live(@55)
        storage_live(@56)
        @56 := &*(a@51)
        storage_live(@57)
        storage_live(@58)
        storage_live(@59)
        @59 := const (100 : i32)
        @58 := &@59
        @57 := &*(@58)
        storage_live(@60)
        storage_live(@61)
        storage_live(@62)
        @62 := const (200 : i64)
        @61 := &@62
        @60 := &*(@61)
        storage_live(@133)
        storage_live(@134)
        @133 := ptr_metadata(move (@56))
        @134 := copy ((*(@133)).3)
        @55 := (move @134)(move (@56), move (@57), move (@60))
        storage_dead(@60)
        storage_dead(@57)
        storage_dead(@56)
        storage_dead(@62)
        storage_dead(@61)
        storage_dead(@59)
        storage_dead(@58)
        storage_dead(@55)
        storage_live(tuple_handler@63)
        storage_live(@64)
        storage_live(@65)
        storage_live(@66)
        // Test tuple and array drop shim generation through trait objects
        @66 := const (42 : i32)
        @65 := &@66
        @64 := &*(@65)
        tuple_handler@63 := unsize_cast<&'_ (i32), &'_ ((dyn exists<_dyn> [@TraitClause0]: DropTuple<_dyn> + _dyn : '_)), {impl DropTuple for i32}>(move (@64))
        storage_dead(@64)
        storage_dead(@65)
        storage_live(@67)
        storage_live(@68)
        storage_live(@69)
        storage_live(@70)
        storage_live(@71)
        @71 := &*(tuple_handler@63)
        storage_live(@72)
        storage_live(@73)
        storage_live(@74)
        storage_live(@75)
        @75 := const ("test")
        @74 := &*(@75)
        @73 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@74))
        storage_dead(@74)
        storage_live(@76)
        storage_live(@77)
        storage_live(@78)
        @139 := [const (1 : i32), const (2 : i32)]
        storage_live(@79)
        @79 := @BoxNew<Array<i32, 2 : usize>>[MetaSized<Array<i32, 2 : usize>>, Sized<Global>](move (@139))
        @78 := move (@79)
        @77 := unsize_cast<alloc::boxed::Box<Array<i32, 2 : usize>>[MetaSized<Array<i32, 2 : usize>>, Sized<Global>], alloc::boxed::Box<Slice<i32>>[MetaSized<Slice<i32>>, Sized<Global>], 2 : usize>(move (@78))
        drop[{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<Array<i32, 2 : usize>, Global>[MetaSized<Array<i32, 2 : usize>>, Sized<Global>]] @78
        drop[{impl Drop for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<Array<i32, 2 : usize>, Global>[MetaSized<Array<i32, 2 : usize>>, Sized<Global>]] @79
        storage_dead(@79)
        storage_dead(@78)
        @76 := into_vec<i32, Global>[Sized<i32>, Sized<Global>](move (@77))
        storage_dead(@77)
        @72 := (move (@73), move (@76))
        drop[{impl Drop for Vec<T>[@TraitClause0, @TraitClause1]}<i32, Global>[Sized<i32>, Sized<Global>]] @76
        storage_dead(@76)
        drop[{impl Drop for String}] @73
        storage_dead(@73)
        storage_live(@135)
        storage_live(@136)
        @135 := ptr_metadata(move (@71))
        @136 := copy ((*(@135)).3)
        @70 := (move @136)(move (@71), move (@72))
        storage_dead(@72)
        storage_dead(@71)
        @69 := &@70
        storage_live(@80)
        storage_live(@81)
        @81 := const (6 : usize)
        @80 := &@81
        @68 := (move (@69), move (@80))
        storage_dead(@80)
        storage_dead(@69)
        storage_live(left_val@82)
        left_val@82 := copy ((@68).0)
        storage_live(right_val@83)
        right_val@83 := copy ((@68).1)
        storage_live(@84)
        storage_live(@85)
        @85 := copy (*(left_val@82))
        storage_live(@86)
        @86 := copy (*(right_val@83))
        @84 := move (@85) == move (@86)
        if move (@84) {
        }
        else {
            storage_dead(@86)
            storage_dead(@85)
            storage_live(kind@87)
            kind@87 := AssertKind::Eq {  }
            storage_live(@88)
            @88 := move (kind@87)
            storage_live(@89)
            storage_live(@90)
            @90 := &*(left_val@82)
            @89 := &*(@90)
            storage_live(@91)
            storage_live(@92)
            @92 := &*(right_val@83)
            @91 := &*(@92)
            storage_live(@93)
            @93 := Option::None {  }
            panic(core::panicking::assert_failed)
        }
        storage_dead(@86)
        storage_dead(@85)
        storage_dead(@84)
        storage_dead(right_val@83)
        storage_dead(left_val@82)
        storage_dead(@81)
        storage_dead(@75)
        storage_dead(@70)
        storage_dead(@68)
        storage_dead(@67)
        storage_live(array_handler@94)
        storage_live(@95)
        storage_live(@96)
        storage_live(@97)
        @97 := const (42 : i32)
        @96 := &@97
        @95 := &*(@96)
        array_handler@94 := unsize_cast<&'_ (i32), &'_ ((dyn exists<_dyn> [@TraitClause0]: DropArray<_dyn> + _dyn : '_)), {impl DropArray for i32}>(move (@95))
        storage_dead(@95)
        storage_dead(@96)
        storage_live(@98)
        storage_live(@99)
        storage_live(@100)
        storage_live(@101)
        storage_live(@102)
        @102 := &*(array_handler@94)
        storage_live(@103)
        storage_live(@104)
        storage_live(@105)
        storage_live(@106)
        @106 := const ("x")
        @105 := &*(@106)
        @104 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@105))
        storage_dead(@105)
        storage_live(@107)
        storage_live(@108)
        storage_live(@109)
        @109 := const ("yy")
        @108 := &*(@109)
        @107 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@108))
        storage_dead(@108)
        storage_live(@110)
        storage_live(@111)
        storage_live(@112)
        @112 := const ("zzz")
        @111 := &*(@112)
        @110 := {impl ToString for T}::to_string<'_, Str>[MetaSized<Str>, {impl Display for Str}](move (@111))
        storage_dead(@111)
        @103 := [move (@104), move (@107), move (@110)]
        drop[{impl Drop for String}] @110
        storage_dead(@110)
        drop[{impl Drop for String}] @107
        storage_dead(@107)
        drop[{impl Drop for String}] @104
        storage_dead(@104)
        storage_live(@137)
        storage_live(@138)
        @137 := ptr_metadata(move (@102))
        @138 := copy ((*(@137)).3)
        @101 := (move @138)(move (@102), move (@103))
        storage_dead(@103)
        storage_dead(@102)
        @100 := &@101
        storage_live(@113)
        storage_live(@114)
        @114 := const (6 : usize)
        @113 := &@114
        @99 := (move (@100), move (@113))
        storage_dead(@113)
        storage_dead(@100)
        storage_live(left_val@115)
        left_val@115 := copy ((@99).0)
        storage_live(right_val@116)
        right_val@116 := copy ((@99).1)
        storage_live(@117)
        storage_live(@118)
        @118 := copy (*(left_val@115))
        storage_live(@119)
        @119 := copy (*(right_val@116))
        @117 := move (@118) == move (@119)
        if move (@117) {
        }
        else {
            storage_dead(@119)
            storage_dead(@118)
            storage_live(kind@120)
            kind@120 := AssertKind::Eq {  }
            storage_live(@121)
            @121 := move (kind@120)
            storage_live(@122)
            storage_live(@123)
            @123 := &*(left_val@115)
            @122 := &*(@123)
            storage_live(@124)
            storage_live(@125)
            @125 := &*(right_val@116)
            @124 := &*(@125)
            storage_live(@126)
            @126 := Option::None {  }
            panic(core::panicking::assert_failed)
        }
        storage_dead(@119)
        storage_dead(@118)
        storage_dead(@117)
        storage_dead(right_val@116)
        storage_dead(left_val@115)
        storage_dead(@114)
        storage_dead(@112)
        storage_dead(@109)
        storage_dead(@106)
        storage_dead(@101)
        storage_dead(@99)
        storage_dead(@98)
        @0 := ()
        storage_dead(@97)
        storage_dead(array_handler@94)
        storage_dead(@66)
        storage_dead(tuple_handler@63)
        storage_dead(@54)
        storage_dead(a@51)
        storage_dead(z@43)
        storage_dead(@11)
        storage_dead(y@8)
        storage_dead(@4)
        storage_dead(x@1)
        @0 := ()
        return
    }
    storage_dead(@14)
    drop[{impl Drop for String}] @15
    drop[{impl Drop for String}] @18
    storage_dead(@20)
    storage_dead(@18)
    storage_dead(@17)
    storage_dead(@15)
    panic(core::panicking::panic)
}



