---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: ssprove
  info:
    name: side-effects
    manifest: side-effects/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 1
stderr = """
Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs
\u001B[1m\u001B[91merror\u001B[0m: \u001B[1m[HAX0001] (SSProve backend) something is not implemented yet.
[expr] node app global vcar projector tuple\u001B[0m
   \u001B[1m\u001B[94m-->\u001B[0m side-effects/src/lib.rs:156:5
\u001B[1m\u001B[94m    |\u001B[0m
\u001B[1m\u001B[94m156 |\u001B[0m     foo.y.1[3].b.0[5].0 = true;
\u001B[1m\u001B[94m    |\u001B[0m\u001B[1m\u001B[91m     ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001B[0m
\u001B[1m\u001B[94m    |\u001B[0m"""
[[stdout.diagnostics]]
message = '''
(SSProve backend) something is not implemented yet.
[expr] node app global vcar projector tuple'''
spans = ['Span { lo: Loc { line: 156, col: 4 }, hi: Loc { line: 156, col: 30 }, filename: Real(LocalPath("side-effects/src/lib.rs")), rust_span_data: None }']

[stdout.files]
"Side_effects.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations add3 (x : both int32) (y : both int32) (z : both int32) : both int32 :=
  add3 x y z  :=
    impl_u32__wrapping_add (impl_u32__wrapping_add x y) z : both int32.
Fail Next Obligation.

Equations local_mutation (x : both int32) : both int32 :=
  local_mutation x  :=
    letb y := ret_both (0 : int32) in
    letb x := impl_u32__wrapping_add x (ret_both (1 : int32)) in
    letb hoist1 := x >.? (ret_both (3 : int32)) in
    ifb hoist1
    then letb x := impl_u32__wrapping_sub x (ret_both (3 : int32)) in
    letb y := x ./ (ret_both (2 : int32)) in
    letb y := impl_u32__wrapping_add y (ret_both (2 : int32)) in
    letb hoist2 := ret_both (0 : int32) in
    letb hoist3 := Build_t_Range (f_start := hoist2) (f_end := ret_both (10 : int32)) in
    letb hoist4 := f_into_iter hoist3 in
    letb y := foldi_both_list hoist4 (fun i =>
      ssp (fun y =>
        impl_u32__wrapping_add x i : (both int32))) y in
    impl_u32__wrapping_add x y
    else letb '((x,y),hoist7) := matchb x with
    | 12 =>
      letb y := impl_u32__wrapping_add x y in
      prod_b (prod_b (x,y),ret_both (3 : int32))
    | 13 =>
      letb hoist6 := x in
      letb x := impl_u32__wrapping_add x (ret_both (1 : int32)) in
      letb hoist5 := impl_u32__wrapping_add (ret_both (123 : int32)) x in
      prod_b (prod_b (x,y),add3 hoist6 hoist5 x)
    | _ =>
      prod_b (prod_b (x,y),ret_both (0 : int32))
    end in
    letb x := hoist7 in
    impl_u32__wrapping_add x y : both int32.
Fail Next Obligation.

Equations early_returns (x : both int32) : both int32 :=
  early_returns x  :=
    run (letm[choice_typeMonad.result_bind_code int32] _ := ifb x >.? (ret_both (3 : int32))
    then letm[choice_typeMonad.result_bind_code int32] hoist8 := ControlFlow_Break (ret_both (0 : int32)) in
    ControlFlow_Continue (never_to_any hoist8)
    else ControlFlow_Continue (ret_both (tt : 'unit)) in
    letb hoist9 := x >.? (ret_both (30 : int32)) in
    letm[choice_typeMonad.result_bind_code int32] '(x,hoist11) := ifb hoist9
    then matchb ret_both (true : 'bool) with
    | true =>
      letm[choice_typeMonad.result_bind_code int32] hoist10 := ControlFlow_Break (ret_both (34 : int32)) in
      ControlFlow_Continue (prod_b (x,never_to_any hoist10))
    | _ =>
      ControlFlow_Continue (prod_b (x,ret_both (3 : int32)))
    end
    else ControlFlow_Continue (letb x := x .+ (ret_both (9 : int32)) in
    prod_b (x,x .+ (ret_both (1 : int32)))) in
    letb hoist12 := impl_u32__wrapping_add (ret_both (123 : int32)) hoist11 in
    letb hoist13 := impl_u32__wrapping_add hoist12 x in
    letm[choice_typeMonad.result_bind_code int32] hoist14 := ControlFlow_Break hoist13 in
    ControlFlow_Continue (never_to_any hoist14)) : both int32.
Fail Next Obligation.

Equations simplifiable_return (c1 : both 'bool) (c2 : both 'bool) (c3 : both 'bool) : both int32 :=
  simplifiable_return c1 c2 c3  :=
    run (letb x := ret_both (0 : int32) in
    letm[choice_typeMonad.result_bind_code int32] x := ifb c1
    then letm[choice_typeMonad.result_bind_code int32] x := ifb c2
    then letb x := x .+ (ret_both (10 : int32)) in
    ifb c3
    then letm[choice_typeMonad.result_bind_code int32] hoist15 := ControlFlow_Break (ret_both (1 : int32)) in
    ControlFlow_Continue x
    else ControlFlow_Continue x
    else ControlFlow_Continue x in
    ControlFlow_Continue (letb x := x .+ (ret_both (1 : int32)) in
    x)
    else ControlFlow_Continue x in
    ControlFlow_Continue x) : both int32.
Fail Next Obligation.

Equations simplifiable_question_mark (c : both 'bool) (x : both (t_Option int32)) : both (t_Option int32) :=
  simplifiable_question_mark c x  :=
    run (letm[choice_typeMonad.option_bind_code] a := ifb c
    then letm[choice_typeMonad.option_bind_code] hoist16 := x in
    Option_Some (hoist16 .+ (ret_both (10 : int32)))
    else Option_Some (ret_both (0 : int32)) in
    Option_Some (letb b := ret_both (20 : int32) in
    Option_Some (a .+ b))) : both (t_Option int32).
Fail Next Obligation.

Equations direct_result_question_mark (y : both (t_Result 'unit int32)) : both (t_Result int8 int32) :=
  direct_result_question_mark y  :=
    run (letm[choice_typeMonad.result_bind_code int32] _ := y in
    Result_Ok (Result_Ok (ret_both (0 : int8)))) : both (t_Result int8 int32).
Fail Next Obligation.

Equations direct_result_question_mark_coercion (y : both (t_Result int8 int16)) : both (t_Result int8 int32) :=
  direct_result_question_mark_coercion y  :=
    run (letm[choice_typeMonad.result_bind_code int32] hoist17 := impl__map_err y f_from in
    Result_Ok (Result_Ok hoist17)) : both (t_Result int8 int32).
Fail Next Obligation.

Equations options (x : both (t_Option int8)) (y : both (t_Option int8)) (z : both (t_Option int64)) : both (t_Option int8) :=
  options x y z  :=
    run (letm[choice_typeMonad.option_bind_code] hoist21 := x in
    letb hoist22 := hoist21 >.? (ret_both (10 : int8)) in
    letm[choice_typeMonad.option_bind_code] hoist28 := ifb hoist22
    then letm[choice_typeMonad.option_bind_code] hoist23 := x in
    Option_Some (letb hoist24 := impl_u8__wrapping_add hoist23 (ret_both (3 : int8)) in
    Option_Some hoist24)
    else letm[choice_typeMonad.option_bind_code] hoist26 := x in
    letm[choice_typeMonad.option_bind_code] hoist25 := y in
    Option_Some (letb hoist27 := impl_u8__wrapping_add hoist26 hoist25 in
    Option_Some hoist27) in
    letm[choice_typeMonad.option_bind_code] hoist29 := hoist28 in
    letm[choice_typeMonad.option_bind_code] v := matchb hoist29 with
    | 3 =>
      Option_None
    | 4 =>
      letm[choice_typeMonad.option_bind_code] hoist18 := z in
      Option_Some (letb hoist19 := hoist18 >.? (ret_both (4 : int64)) in
      letb hoist20 := ifb hoist19
      then ret_both (0 : int8)
      else ret_both (3 : int8) in
      (ret_both (4 : int8)) .+ hoist20)
    | _ =>
      Option_Some (ret_both (12 : int8))
    end in
    letm[choice_typeMonad.option_bind_code] hoist30 := x in
    letb hoist32 := impl_u8__wrapping_add v hoist30 in
    letm[choice_typeMonad.option_bind_code] hoist31 := y in
    Option_Some (letb hoist33 := impl_u8__wrapping_add hoist32 hoist31 in
    Option_Some hoist33)) : both (t_Option int8).
Fail Next Obligation.

Equations question_mark (x : both int32) : both (t_Result int32 int32) :=
  question_mark x  :=
    run (letm[choice_typeMonad.result_bind_code int32] x := ifb x >.? (ret_both (40 : int32))
    then letb y := ret_both (0 : int32) in
    letb x := impl_u32__wrapping_add x (ret_both (3 : int32)) in
    letb y := impl_u32__wrapping_add x y in
    letb x := impl_u32__wrapping_add x y in
    letb hoist34 := x >.? (ret_both (90 : int32)) in
    ifb hoist34
    then letm[choice_typeMonad.result_bind_code int32] _ := impl__map_err (Result_Err (ret_both (12 : int8))) f_from in
    Result_Ok x
    else Result_Ok x
    else Result_Ok x in
    Result_Ok (Result_Ok (impl_u32__wrapping_add (ret_both (3 : int32)) x))) : both (t_Result int32 int32).
Fail Next Obligation.

Definition t_A : choice_type :=
  'unit.
Equations Build_t_A : both (t_A) :=
  Build_t_A  :=
    ret_both (tt (* Empty tuple *) : (t_A)) : both (t_A).
Fail Next Obligation.

Definition t_B : choice_type :=
  'unit.
Equations Build_t_B : both (t_B) :=
  Build_t_B  :=
    ret_both (tt (* Empty tuple *) : (t_B)) : both (t_B).
Fail Next Obligation.

Equations monad_lifting (x : both int8) : both (t_Result t_A t_B) :=
  monad_lifting x  :=
    run (ifb x >.? (ret_both (123 : int8))
    then letm[choice_typeMonad.result_bind_code (t_Result t_A t_B)] hoist35 := ControlFlow_Continue (Result_Err B) in
    letb hoist36 := Result_Ok hoist35 in
    letm[choice_typeMonad.result_bind_code (t_Result t_A t_B)] hoist37 := ControlFlow_Break hoist36 in
    ControlFlow_Continue (never_to_any hoist37)
    else ControlFlow_Continue (Result_Ok A)) : both (t_Result t_A t_B).
Fail Next Obligation.

Definition t_Bar : choice_type :=
  ('bool × nseq ('bool × 'bool) 6 × 'bool).
Equations f_a (s : both t_Bar) : both 'bool :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (fst x : 'bool)) : both 'bool.
Fail Next Obligation.
Equations f_b (s : both t_Bar) : both (nseq ('bool × 'bool) 6 × 'bool) :=
  f_b s  :=
    bind_both s (fun x =>
      ret_both (snd x : (nseq ('bool × 'bool) 6 × 'bool))) : both (nseq ('bool × 'bool) 6 × 'bool).
Fail Next Obligation.
Equations Build_t_Bar {f_a : both 'bool} {f_b : both (nseq ('bool × 'bool) 6 × 'bool)} : both (t_Bar) :=
  Build_t_Bar  :=
    bind_both f_b (fun f_b =>
      bind_both f_a (fun f_a =>
        ret_both ((f_a,f_b) : (t_Bar)))) : both (t_Bar).
Fail Next Obligation.
Notation "'Build_t_Bar' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_Bar (f_a := y) (f_b := f_b x)).
Notation "'Build_t_Bar' '[' x ']' '(' 'f_b' ':=' y ')'" := (Build_t_Bar (f_a := f_a x) (f_b := y)).

Definition t_Foo : choice_type :=
  ('bool × 'bool × t_Vec t_Bar t_Global × nseq t_Bar 6 × t_Bar).
Equations f_x (s : both t_Foo) : both 'bool :=
  f_x s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : 'bool)) : both 'bool.
Fail Next Obligation.
Equations f_y (s : both t_Foo) : both ('bool × t_Vec t_Bar t_Global) :=
  f_y s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : ('bool × t_Vec t_Bar t_Global))) : both ('bool × t_Vec t_Bar t_Global).
Fail Next Obligation.
Equations f_z (s : both t_Foo) : both (nseq t_Bar 6) :=
  f_z s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : (nseq t_Bar 6))) : both (nseq t_Bar 6).
Fail Next Obligation.
Equations f_bar (s : both t_Foo) : both t_Bar :=
  f_bar s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Bar)) : both t_Bar.
Fail Next Obligation.
Equations Build_t_Foo {f_x : both 'bool} {f_y : both ('bool × t_Vec t_Bar t_Global)} {f_z : both (nseq t_Bar 6)} {f_bar : both t_Bar} : both (t_Foo) :=
  Build_t_Foo  :=
    bind_both f_bar (fun f_bar =>
      bind_both f_z (fun f_z =>
        bind_both f_y (fun f_y =>
          bind_both f_x (fun f_x =>
            ret_both ((f_x,f_y,f_z,f_bar) : (t_Foo)))))) : both (t_Foo).
Fail Next Obligation.
Notation "'Build_t_Foo' '[' x ']' '(' 'f_x' ':=' y ')'" := (Build_t_Foo (f_x := y) (f_y := f_y x) (f_z := f_z x) (f_bar := f_bar x)).
Notation "'Build_t_Foo' '[' x ']' '(' 'f_y' ':=' y ')'" := (Build_t_Foo (f_x := f_x x) (f_y := y) (f_z := f_z x) (f_bar := f_bar x)).
Notation "'Build_t_Foo' '[' x ']' '(' 'f_z' ':=' y ')'" := (Build_t_Foo (f_x := f_x x) (f_y := f_y x) (f_z := y) (f_bar := f_bar x)).
Notation "'Build_t_Foo' '[' x ']' '(' 'f_bar' ':=' y ')'" := (Build_t_Foo (f_x := f_x x) (f_y := f_y x) (f_z := f_z x) (f_bar := y)).

(*item error backend*)
'''
"Side_effects_Issue_1083_.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Class t_MyFrom (Self : choice_type) (v_Self : v_Self) {v_T : v_T} `{ t_Sized v_T} := {
  f_my_from : (both v_T -> both v_Self) ;
}.

#[global] Program Instance int16_t_MyFrom : t_MyFrom int16 int8 :=
  let f_my_from := fun  (x : both int8) => cast_int (WS2 := _) x : both int16 in
  {| f_my_from := (@f_my_from)|}.
Fail Next Obligation.
Hint Unfold int16_t_MyFrom.

Equations f (x : both int8) : both (t_Result int16 int16) :=
  f x  :=
    run (letm[choice_typeMonad.result_bind_code int16] _ := impl__map_err (Result_Err (ret_both (1 : int8))) f_from in
    Result_Ok (Result_Ok (f_my_from x))) : both (t_Result int16 int16).
Fail Next Obligation.
'''
"Side_effects_Issue_1089_.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations test (x : both (t_Option int32)) (y : both (t_Option int32)) : both (t_Option int32) :=
  test x y  :=
    run (impl__map x (fun i =>
      letm[choice_typeMonad.option_bind_code] hoist38 := y in
      Option_Some (letb hoist39 := i .+ hoist38 in
      Option_Some hoist39))) : both (t_Option int32).
Fail Next Obligation.
'''
"Side_effects_Issue_1299_.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_Foo : choice_type :=
  (int8).
Equations f_y (s : both t_Foo) : both int8 :=
  f_y s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_Foo {f_y : both int8} : both (t_Foo) :=
  Build_t_Foo  :=
    bind_both f_y (fun f_y =>
      ret_both ((f_y) : (t_Foo))) : both (t_Foo).
Fail Next Obligation.
Notation "'Build_t_Foo' '[' x ']' '(' 'f_y' ':=' y ')'" := (Build_t_Foo (f_y := y)).

Definition t_S : choice_type :=
  (t_Foo).
Equations f_g (s : both t_S) : both t_Foo :=
  f_g s  :=
    bind_both s (fun x =>
      ret_both (x : t_Foo)) : both t_Foo.
Fail Next Obligation.
Equations Build_t_S {f_g : both t_Foo} : both (t_S) :=
  Build_t_S  :=
    bind_both f_g (fun f_g =>
      ret_both ((f_g) : (t_S))) : both (t_S).
Fail Next Obligation.
Notation "'Build_t_S' '[' x ']' '(' 'f_g' ':=' y ')'" := (Build_t_S (f_g := y)).

Definition t_OtherS : choice_type :=
  (t_Option t_Foo).
Equations f_g (s : both t_OtherS) : both (t_Option t_Foo) :=
  f_g s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Option t_Foo))) : both (t_Option t_Foo).
Fail Next Obligation.
Equations Build_t_OtherS {f_g : both (t_Option t_Foo)} : both (t_OtherS) :=
  Build_t_OtherS  :=
    bind_both f_g (fun f_g =>
      ret_both ((f_g) : (t_OtherS))) : both (t_OtherS).
Fail Next Obligation.
Notation "'Build_t_OtherS' '[' x ']' '(' 'f_g' ':=' y ')'" := (Build_t_OtherS (f_g := y)).

Equations impl_Foo__from (i : both t_Foo) : both t_Foo :=
  impl_Foo__from i  :=
    Build_t_Foo (f_y := f_clone (f_y i)) : both t_Foo.
Fail Next Obligation.

Definition t_Error : choice_type :=
  'unit.
Equations Build_t_Error : both (t_Error) :=
  Build_t_Error  :=
    ret_both (tt (* Empty tuple *) : (t_Error)) : both (t_Error).
Fail Next Obligation.

Equations impl_S__from (i : both t_OtherS) : both (t_Result t_S t_Error) :=
  impl_S__from i  :=
    run (letm[choice_typeMonad.result_bind_code t_Error] hoist49 := impl__ok_or (impl__as_ref (f_g i)) Error in
    Result_Ok (letb hoist50 := impl_Foo__from hoist49 in
    letb hoist51 := Build_t_S (f_g := hoist50) in
    Result_Ok hoist51)) : both (t_Result t_S t_Error).
Fail Next Obligation.
'''
"Side_effects_Issue_1300_.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations fun (_ : both 'unit) : both (t_Result 'unit int8) :=
  fun _  :=
    letb val := f_collect (f_map (impl__iter (unsize (repeat (ret_both (0 : int8)) (ret_both (5 : uint_size))))) (fun prev =>
      letb hoist47 := Result_Ok (repeat (ret_both (0 : int8)) (ret_both (32 : uint_size))) in
      letb hoist48 := prod_b (prev,hoist47) in
      Result_Ok hoist48)) in
    Result_Ok (ret_both (tt : 'unit)) : both (t_Result 'unit int8).
Fail Next Obligation.
'''
"Side_effects_Nested_return.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations other_fun (rng : both int8) : both (int8 × t_Result 'unit 'unit) :=
  other_fun rng  :=
    letb hax_temp_output := Result_Ok (ret_both (tt : 'unit)) in
    prod_b (rng,hax_temp_output) : both (int8 × t_Result 'unit 'unit).
Fail Next Obligation.

Equations fun (rng : both int8) : both (int8 × t_Result 'unit 'unit) :=
  fun rng  :=
    run (letb '(tmp0,out) := other_fun rng in
    letb rng := tmp0 in
    letb hoist41 := out in
    letb hoist42 := f_branch hoist41 in
    letm[choice_typeMonad.result_bind_code (int8 × t_Result 'unit 'unit)] hoist43 := matchb hoist42 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible 'unit)) in
      letm[choice_typeMonad.result_bind_code (int8 × t_Result 'unit 'unit)] hoist40 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist40)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    letb hoist44 := Result_Ok hoist43 in
    letb hoist45 := prod_b (rng,hoist44) in
    letm[choice_typeMonad.result_bind_code (int8 × t_Result 'unit 'unit)] hoist46 := ControlFlow_Break hoist45 in
    ControlFlow_Continue (letb hax_temp_output := never_to_any hoist46 in
    prod_b (rng,hax_temp_output))) : both (int8 × t_Result 'unit 'unit).
Fail Next Obligation.
'''
