---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"Lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false

structure Lean_tests.Structs.T0 where


structure Lean_tests.Structs.T1 A where
  _0 : A

structure Lean_tests.Structs.T2 A B where
  _0 : A
  _1 : B

structure Lean_tests.Structs.T3 A B C where
  _0 : A
  _1 : B
  _2 : C

structure Lean_tests.Structs.T3p A B C where
  _0 : A
  _1 : (Lean_tests.Structs.T2 B C)

def Lean_tests.Structs.tuple_structs  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let t0 : Lean_tests.Structs.T0 ← (pure Lean_tests.Structs.T0.mk);
  let t1 : (Lean_tests.Structs.T1 i32) ←
    (pure (Lean_tests.Structs.T1.mk (1 : i32)));
  let t2 : (Lean_tests.Structs.T2 i32 i32) ←
    (pure (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)));
  let
    t3 : (Lean_tests.Structs.T3 Lean_tests.Structs.T0 (Lean_tests.Structs.T1
    i32) (Lean_tests.Structs.T2 i32 i32)) ←
    (pure
    (Lean_tests.Structs.T3.mk
    Lean_tests.Structs.T0.mk
    (Lean_tests.Structs.T1.mk (1 : i32))
    (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32))));
  let
    t3p : (Lean_tests.Structs.T3p Lean_tests.Structs.T0 (Lean_tests.Structs.T1
    i32) (Lean_tests.Structs.T2 i32 i32)) ←
    (pure
    (Lean_tests.Structs.T3p.mk
    Lean_tests.Structs.T0.mk
    (Lean_tests.Structs.T2.mk
    (Lean_tests.Structs.T1.mk (1 : i32))
    (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)))));
  let (⟨⟩ : Lean_tests.Structs.T0) ← (pure t0);
  let (⟨(u1 : i32)⟩ : (Lean_tests.Structs.T1 i32)) ← (pure t1);
  let (⟨(u2 : i32), (u3 : i32)⟩ : (Lean_tests.Structs.T2 i32 i32)) ← (pure t2);
  let
    (⟨(⟨⟩ : Lean_tests.Structs.T0),
      (⟨(_ : i32)⟩ : (Lean_tests.Structs.T1 i32)),
      (⟨(_ : i32), (_ : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩ :
    (Lean_tests.Structs.T3 Lean_tests.Structs.T0 (Lean_tests.Structs.T1 i32)
    (Lean_tests.Structs.T2 i32 i32))) ←
    (pure t3);
  let
    (⟨(⟨⟩ : Lean_tests.Structs.T0),
      (⟨(⟨(_ : i32)⟩ : (Lean_tests.Structs.T1 i32)),
        (⟨(_ : i32), (_ : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩ :
      (Lean_tests.Structs.T2 (Lean_tests.Structs.T1 i32) (Lean_tests.Structs.T2
      i32 i32)))⟩ : (Lean_tests.Structs.T3p Lean_tests.Structs.T0
    (Lean_tests.Structs.T1 i32) (Lean_tests.Structs.T2 i32 i32))) ←
    (pure t3p);
  let (_ : i32) ← (pure (Lean_tests.Structs.T1._0 t1));
  let (_ : i32) ← (pure (Lean_tests.Structs.T2._0 t2));
  let (_ : i32) ← (pure (Lean_tests.Structs.T2._1 t2));
  let (_ : Lean_tests.Structs.T0) ← (pure (Lean_tests.Structs.T3._0 t3));
  let (_ : (Lean_tests.Structs.T1 i32)) ← (pure (Lean_tests.Structs.T3._1 t3));
  let (_ : (Lean_tests.Structs.T2 i32 i32)) ←
    (pure (Lean_tests.Structs.T3._2 t3));
  let (_ : i32) ←
    (pure (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3._2 t3)));
  let (_ : Lean_tests.Structs.T0) ← (pure (Lean_tests.Structs.T3p._0 t3p));
  let
    (_ : (Lean_tests.Structs.T2 (Lean_tests.Structs.T1 i32)
    (Lean_tests.Structs.T2 i32 i32))) ←
    (pure (Lean_tests.Structs.T3p._1 t3p));
  let (_ : i32) ←
    (pure
    (Lean_tests.Structs.T2._0
      (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p))));
  let (_ : (Lean_tests.Structs.T1 i32)) ←
    (pure (Lean_tests.Structs.T2._0 (Lean_tests.Structs.T3p._1 t3p)));
  let (_ : (Lean_tests.Structs.T2 i32 i32)) ←
    (pure (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p)));
  let (_ : Rust_primitives.Hax.Tuple0) ←
    (pure (match t0 with | ⟨⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ←
    (pure (match t1 with | ⟨(u1 : i32)⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ←
    (pure
    (match t2 with
      | ⟨(u2 : i32), (u3 : i32)⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ←
    (pure
    (match t3 with
      | ⟨(⟨⟩ : Lean_tests.Structs.T0),
         (⟨(u1 : i32)⟩ : (Lean_tests.Structs.T1 i32)),
         (⟨(u2 : i32), (u3 : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩
        => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ←
    (pure
    (match t3p with
      | ⟨(⟨⟩ : Lean_tests.Structs.T0),
         (⟨(⟨(u1 : i32)⟩ : (Lean_tests.Structs.T1 i32)),
           (⟨(u2 : i32), (u3 : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩ :
         (Lean_tests.Structs.T2 (Lean_tests.Structs.T1 i32)
         (Lean_tests.Structs.T2 i32 i32)))⟩
        => do Rust_primitives.Hax.Tuple0.mk));
  Rust_primitives.Hax.Tuple0.mk

structure Lean_tests.Structs.S1 where
  f1 : usize
  f2 : usize

structure Lean_tests.Structs.S2 where
  f1 : Lean_tests.Structs.S1
  f2 : usize

structure Lean_tests.Structs.S3 where
  _end : usize
  _def : usize
  _theorem : usize
  _structure : usize
  _inductive : usize

def Lean_tests.Structs.normal_structs  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let s1 : Lean_tests.Structs.S1 ←
    (pure (Lean_tests.Structs.S1.mk (f1 := (0 : usize)) (f2 := (1 : usize))));
  let s2 : Lean_tests.Structs.S2 ←
    (pure
    (Lean_tests.Structs.S2.mk
    (f1 := (Lean_tests.Structs.S1.mk (f1 := (2 : usize)) (f2 := (3 : usize))))
    (f2 := (4 : usize))));
  let s3 : Lean_tests.Structs.S3 ←
    (pure
    (Lean_tests.Structs.S3.mk
    (_end := (0 : usize))
    (_def := (0 : usize))
    (_theorem := (0 : usize))
    (_structure := (0 : usize))
    (_inductive := (0 : usize))));
  let ({f1 := (f1 : usize), f2 := (f2 : usize)} : Lean_tests.Structs.S1) ←
    (pure s1);
  let
    ({f1 := (f1 : usize), f2 := (other_name_for_f2 : usize)} :
    Lean_tests.Structs.S1) ←
    (pure s1);
  let
    ({f1 := ({f1 := (f1 : usize), f2 := (f2 : usize)} : Lean_tests.Structs.S1),
      f2 := (other_name_for_f2 : usize)} : Lean_tests.Structs.S2) ←
    (pure s2);
  let
    ({_end := (_end : usize),
      _def := (_def : usize),
      _theorem := (_theorem : usize),
      _structure := (_structure : usize),
      _inductive := (_inductive : usize)} : Lean_tests.Structs.S3) ←
    (pure s3);
  let (_ : (Rust_primitives.Hax.Tuple2 usize usize)) ←
    (pure
    (Rust_primitives.Hax.Tuple2.mk
    (Lean_tests.Structs.S1.f1 s1) (Lean_tests.Structs.S1.f2 s1)));
  let
    (_ : (Rust_primitives.Hax.Tuple8 usize usize usize usize usize usize usize
    usize)) ←
    (pure
    (Rust_primitives.Hax.Tuple8.mk
    (Lean_tests.Structs.S1.f1 s1)
    (Lean_tests.Structs.S1.f2 s1)
    (Lean_tests.Structs.S1.f1 (Lean_tests.Structs.S2.f1 s2))
    (Lean_tests.Structs.S1.f2 (Lean_tests.Structs.S2.f1 s2))
    (Lean_tests.Structs.S2.f2 s2)
    (Lean_tests.Structs.S3._end s3)
    (Lean_tests.Structs.S3._def s3)
    (Lean_tests.Structs.S3._theorem s3)));
  let (_ : Rust_primitives.Hax.Tuple0) ←
    (pure
    (match s1 with
      | {f1 := (f1 : usize), f2 := (f2 : usize)}
        => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ←
    (pure
    (match s2 with
      | {f1 := ({f1 := (f1 : usize), f2 := (other_name_for_f2 : usize)} :
         Lean_tests.Structs.S1),
         f2 := (f2 : usize)}
        => do Rust_primitives.Hax.Tuple0.mk));
  (match s3 with
    | {_end := (_end : usize),
       _def := (_def : usize),
       _theorem := (_theorem : usize),
       _structure := (_structure : usize),
       _inductive := (_inductive : usize)}
      => do Rust_primitives.Hax.Tuple0.mk)

inductive Lean_tests.Enums.E : Type
| V1  : Lean_tests.Enums.E
| V2  : Lean_tests.Enums.E
| V3  : usize -> Lean_tests.Enums.E
| V4  : usize -> usize -> usize -> Lean_tests.Enums.E
| V5 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E
| V6 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E


inductive Lean_tests.Enums.MyList (T : Type) : Type
| Nil  : Lean_tests.Enums.MyList T
| Cons (hd : T)
       (tl : (Alloc.Boxed.Box (Lean_tests.Enums.MyList T) Alloc.Alloc.Global)) :
  Lean_tests.Enums.MyList T


def Lean_tests.Enums.enums  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let e_v1 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V1);
  let e_v2 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V2);
  let e_v3 : Lean_tests.Enums.E ← (pure (Lean_tests.Enums.E.V3 (23 : usize)));
  let e_v4 : Lean_tests.Enums.E ←
    (pure (Lean_tests.Enums.E.V4 (23 : usize) (12 : usize) (1 : usize)));
  let e_v5 : Lean_tests.Enums.E ←
    (pure (Lean_tests.Enums.E.V5 (f1 := (23 : usize)) (f2 := (43 : usize))));
  let e_v6 : Lean_tests.Enums.E ←
    (pure (Lean_tests.Enums.E.V6 (f1 := (12 : usize)) (f2 := (13 : usize))));
  let (nil : (Lean_tests.Enums.MyList usize)) ←
    (pure Lean_tests.Enums.MyList.Nil);
  let cons_1 : (Lean_tests.Enums.MyList usize) ←
    (pure (Lean_tests.Enums.MyList.Cons (hd := (1 : usize)) (tl := nil)));
  let cons_2_1 : (Lean_tests.Enums.MyList usize) ←
    (pure (Lean_tests.Enums.MyList.Cons (hd := (2 : usize)) (tl := cons_1)));
  (match e_v1 with
    | (Lean_tests.Enums.E.V1 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V2 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V3 (_ : usize)) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V4 (x1 : usize) (x2 : usize) (x3 : usize))
      => do
        let y1 : usize ← (pure (← x1 +? x2));
        let y2 : usize ← (pure (← y1 -? x2));
        let y3 : usize ← (pure (← y2 +? x3));
        Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V5 (f1 := (f1 : usize)) (f2 := (f2 : usize)))
      => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V6
        (f1 := (f1 : usize)) (f2 := (other_name_for_f2 : usize)))
      => do Rust_primitives.Hax.Tuple0.mk)

def Lean_tests.FORTYTWO : usize := 42

def Lean_tests.MINUS_FORTYTWO : isize := -42

def Lean_tests.returns42  (_ : Rust_primitives.Hax.Tuple0) : Result usize := do
  Lean_tests.FORTYTWO

def Lean_tests.add_two_numbers  (x : usize) (y : usize) : Result usize := do
  (← x +? y)

def Lean_tests.letBinding  (x : usize) (y : usize) : Result usize := do
  let useless : Rust_primitives.Hax.Tuple0 ←
    (pure Rust_primitives.Hax.Tuple0.mk);
  let result1 : usize ← (pure (← x +? y));
  let result2 : usize ← (pure (← result1 +? (2 : usize)));
  (← result2 +? (1 : usize))

def Lean_tests.closure  (_ : Rust_primitives.Hax.Tuple0) : Result i32 := do
  let x : i32 ← (pure (41 : i32));
  let f1 : i32 -> Result i32 ←
    (pure (fun (y : i32) => (do (← y +? x) : Result i32)));
  let f2 : i32 -> i32 -> Result i32 ←
    (pure (fun (y : i32) (z : i32) => (do (← (← y +? x) +? z) : Result i32)));
  let res1 : i32 ←
    (pure
    (← Core.Ops.Function.Fn.call f1 (Rust_primitives.Hax.Tuple1.mk (1 : i32))));
  let res2 : i32 ←
    (pure
    (← Core.Ops.Function.Fn.call
      f2
      (Rust_primitives.Hax.Tuple2.mk (2 : i32) (3 : i32))));
  (← res1 +? res2)

@[spec]

def Lean_tests.test_before_verbatime_single_line  (x : u8) : Result u8 := do 42


def multiline : Unit := ()


def Lean_tests.test_before_verbatim_multi_line  (x : u8) : Result u8 := do 32

def Lean_tests.binop_resugarings  (x : u32) : Result u32 := do
  let add : u32 ← (pure (← x +? (1 : u32)));
  let sub : u32 ← (pure (← add -? (2 : u32)));
  let mul : u32 ← (pure (← sub *? (3 : u32)));
  let rem : u32 ← (pure (← mul %? (4 : u32)));
  let div : u32 ← (pure (← rem /? (5 : u32)));
  let rshift : u32 ← (pure (← div >>>? x));
  x'''
