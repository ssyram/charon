# Charon Development Architecture and Translation Tutorial

This tutorial is designed for developers who want to quickly understand and modify the Charon project's compiler intermediate representation. It progressively explains Charon's architecture and implementation, from a high-level functional overview to detailed internal mechanisms.

## 1. Repository Functionality Overview

**Charon's Main Functionality**: Compile Rust crates into LLBC (Low-Level Borrow Calculus) intermediate representation or ULLBC (Unstructured LLBC) intermediate representation
- Input: Rust source code project
- Process: Obtain MIR through Rustc → Translate to ULLBC [→ Transform to LLBC]
- Output: (U)LLBC files in JSON format for downstream formal verification tools

**charon-ml Functionality**: Provides AST parsing for OCaml tools
- Automatically generates OCaml type definitions and JSON deserialization code
- When AST is modified in Rust, run `make generate-ml` to sync to ML
- Contains hand-written printing and name matching utilities

## 2. Complete Directory Structure

```
charon/                          # Project root directory
├── charon/                      # Rust implementation main body
│   ├── src/
│   │   ├── bin/
│   │   │   ├── charon/          # Entry executable
│   │   │   │   └── main.rs      # Main entry: set up environment and call charon-driver
│   │   │   ├── charon-driver/   # Core translation driver
│   │   │   │   ├── main.rs      # Driver entry: invoke Rustc
│   │   │   │   ├── driver.rs    # Rustc callback configuration
│   │   │   │   └── translate/   # Translation module ⭐ Most complex
│   │   │   │       ├── translate_crate.rs     # Translation dispatch main loop
│   │   │   │       ├── translate_ctx.rs       # Translation context
│   │   │   │       ├── translate_items.rs     # Item dispatch translation
│   │   │   │       ├── translate_generics.rs  # Generics handling
│   │   │   │       ├── translate_functions.rs # Function translation
│   │   │   │       ├── translate_types.rs     # Type translation
│   │   │   │       └── ...                    # Other translation sub-modules
│   │   │   └── generate-ml/     # ML code generator
│   │   ├── ast/                 # AST definitions
│   │   │   ├── gast.rs          # Generic AST structures
│   │   │   ├── types.rs         # Type system and generics
│   │   │   ├── llbc_ast.rs      # LLBC AST
│   │   │   └── ullbc_ast.rs     # ULLBC AST
│   │   ├── transform/           # Transformation passes
│   │   │   ├── mod.rs           # Pass definitions and ordering
│   │   │   ├── ullbc_to_llbc.rs # Control flow reconstruction
│   │   │   └── ...              # Various cleanup passes
│   │   ├── ids/                 # ID type definitions
│   │   ├── common.rs            # Common utilities
│   │   ├── export.rs            # Serialization output
│   │   └── lib.rs               # Library entry
│   ├── tests/                   # Test cases
│   └── Makefile
├── charon-ml/                   # OCaml implementation (downstream tool interface)
│   ├── src/
│   │   ├── generated/           # Auto-generated (do not manually modify)
│   │   │   ├── Generated_GAst.ml
│   │   │   ├── Generated_GAstOfJson.ml
│   │   │   └── ...
│   │   ├── GAst.ml              # Hand-written AST helpers
│   │   ├── PrintGAst.ml         # Hand-written printing utilities
│   │   ├── NameMatcher.ml       # Hand-written name matching
│   │   └── ...
│   └── tests/
├── docs/                        # Documentation
├── scripts/                     # Helper scripts
└── Makefile                     # Top-level build
```

**Key Notes**:
- The `translate/` directory has the highest complexity and contains the core translation logic
- `charon-ml/src/generated/` is auto-generated by `make generate-ml`; do not manually modify
- After modifying the AST, you must run `make generate-ml` to sync to ML

## 3. Charon's Overall Working Mechanism

### 3.1 Complete Call Flow

**Entry Flow**: `charon` → `charon-driver` → Rustc → Callback (MIR) → translate → transform

**Key Functions at Each Stage**:

1. **charon executable** (`charon/src/bin/charon/main.rs`)
   - `main()` function: Parse command-line arguments
   - Set environment variable `RUSTC_WRAPPER=charon-driver`
   - Invoke `cargo` or run Rustc directly

2. **charon-driver** (`charon/src/bin/charon-driver/main.rs`)
   - `main()` → `run_charon()` entry point
   - `driver::run_rustc_driver()` starts Rustc compilation
   > Note: This is the standard approach for Rust tool development. The compiled `charon-driver` binary acts as a Rustc wrapper. When Cargo is invoked, the Rustc used will be `charon-driver`, which first runs the normal Rustc syntax analysis pipeline and then calls callback functions at the MIR stage
   - Rustc callback configuration is in `driver.rs`

3. **driver.rs key configuration** (`charon/src/bin/charon-driver/driver.rs`)
   - `run_rustc_driver()` sets up Rustc callbacks
   - `after_expansion()` callback: Called after MIR generation is complete
   - Invokes the **key function** `translate_crate::translate()` to start the translation process

4. **Translation Dispatch** (`translate/translate_crate.rs`)
   - This stage is responsible for importing source code information from Rustc and translating it to ULLBC representation. Note that although the translation process can directly interact with Rustc, it actually introduces Hax as a **key abstraction layer** to convert Rustc MIR into a Hax representation that is more suitable for translation needs
   > **Core Role of Hax**: Hax is an important component in Charon's architecture with the following main responsibilities:
   > 1. **Handle all Rustc queries**: Hax handles the complexity of interacting with Rustc, so Charon code doesn't need to deal with Rustc's low-level details directly
   > 2. **Handle Rustc interface changes**: Hax isolates potential changes in Rustc's interface, making Charon more robust to Rustc version updates
   > 3. **DefId abstraction**: Hax's DefId can represent either Rustc's DefId or promoted constants (the latter doesn't have an independent DefId in Rustc)
   > 4. **Trait resolution support**: Hax is responsible for creating TraitRefKind::Clause and TraitRefKind::ParentClause data. Rustc only provides TraitDeclRef (in Charon's terminology). When we ask "how to prove this trait is implemented," if Rustc can find an impl block, it will give it to us. But for constraints like `T: Clone` (which holds because we're inside `fn foo<T: Clone>`), Rustc won't directly tell us this is a Clause; Hax needs to construct this information
   > 5. **Support polymorphic and monomorphic modes**: For scenarios that need to support both polymorphic and monomorphic translation, Hax's FullDef abstraction can uniformly handle differences between the two modes, simplifying implementation
   > 
   > It's worth noting that while theoretically possible to bypass Hax and use Rustc directly, this would bring significant additional burden, including the need to handle all the complexity of Rustc queries and interface changes ourselves. Therefore, Hax is indispensable in practice
   - `translate()` function: Main translation entry point
   - Create `TranslateCtx` context
   - Initialize, start, and manage the entire translation loop (detailed description below)

5. **(U)LLBC Transformation Stage** (back to `charon-driver/main.rs`)
   - This stage first performs ULLBC transformations, then converts to LLBC, and finally performs LLBC transformations. These transformations **do not** introduce new Rustc translation items—they don't add new information from source code, only perform further calculations on existing information, implementing normalization operations such as converting `[i]` index access to function calls
   - After translation completes in `run_charon()`
   - Iterate through and execute `transformation_passes()`
   - Finally serialize and output

### 3.2 Key Transition Point Code Examples

Here are key code snippets from each stage to help understand the overall call flow.

```rust
// Entry: charon/src/bin/charon/main.rs
fn main() {
    // Set RUSTC_WRAPPER environment variable pointing to charon-driver
    // Call cargo or rustc
}

// Driver: charon/src/bin/charon-driver/main.rs
fn run_charon(options: CliOpts) {
    let ctx = driver::run_rustc_driver(&options)?;  // ← Call Rustc
    // Execute transform passes
    for pass in transformation_passes(&options) {
        pass.run(&mut ctx);
    }
}

// Callback: charon/src/bin/charon-driver/driver.rs
impl Callbacks for CharonCallbacks {
    fn after_expansion(&mut self, compiler: &Compiler) {
        // Rustc expansion complete, MIR available
        let tcx = compiler.tcx();  // Get type context
        translate_crate::translate(tcx, options)  // ← Start translation
    }
}

// Translation: charon/src/bin/charon-driver/translate/translate_crate.rs
pub fn translate(tcx: TyCtxt, options: CliOpts) -> TransformCtx {
    let mut ctx = TranslateCtx::new(tcx, options);
    ctx.enqueue_module_item(...);  // Add starting items
    
    // ⭐ Core translation loop
    while let Some(item_src) = ctx.items_to_translate.pop_first() {
        ctx.translate_item(&item_src);
    }
    
    // Return context for transform
}
```

## 4. Detailed Translation Stage Flow

The translation stage is the core of Charon's capabilities, responsible for converting Rustc MIR to ULLBC. Its core is a queue-based work scheduling system that ensures all items that need translation are processed exactly once.

### 4.1 Translation Abstract Algorithm Description

**Core Loop** (`translate_crate.rs` around line 674):
```rust
while let Some(item_src) = ctx.items_to_translate.pop_first() {
    if ctx.processed.insert(item_src.clone()) {
        ctx.translate_item(&item_src);
    }
}
```

**Algorithm Steps**:
1. **Initialization**: Create `TranslateCtx` with an empty `items_to_translate` queue
2. **Seed Addition**: Call `enqueue_module_item()` to add starting items (usually the crate root) to the queue
3. **Loop Processing**: Take an item from the queue and call `translate_item()` to translate it
4. **Dependency Discovery**: During translation, when dependencies are encountered (defined functions, used library functions, library types, types involved in types, etc.), they are added to the queue via `enqueue`. The main translation type here is `TransItemSource`, which contains two core fields: `RustcItem` and `TransItemSourceKind`. The former represents the specific Rustc entity being referenced (actually a Hax entity), and the latter represents the Charon target type for this entity.
> Note: One `RustcItem` may correspond to multiple `TransItemSource` instances. For example, when `RustcItem` corresponds to a specific trait, `TransItemSource` might be `Trait` representing the translation of the trait itself, or `VTable` representing the virtual table struct definition for that trait.
5. **Deduplication Check**: The `processed` set ensures each item is translated only once
6. **Completion Condition**: Translation ends when the queue is empty

### 4.2 Core Data Structure Analysis

#### `TranslateCtx` Structure

`TranslateCtx` is the core global context for the translation stage, managing **overall translation** state and data.

**Global Translation Context** (`translate/translate_ctx.rs` around line 48):
```rust
pub struct TranslateCtx<'tcx> {
    pub tcx: TyCtxt<'tcx>,                          // Rustc type context
    pub hax_state: hax::State<'tcx, Base>,          // Hax conversion state
    pub options: CliOpts,                            // Command-line options
    
    // ⭐ Translation dispatch core
    pub items_to_translate: BTreeSet<TransItemSource>,  // Items to translate queue
    pub processed: BTreeSet<TransItemSource>,           // Processed items set
    
    // Registration and storage
    pub id_map: HashMap<TransItemSource, AnyTransId>,   // Source -> ID mapping
    pub translated: TranslatedCrate,                     // Translation result storage
    
    // Error handling
    pub errors: ErrorCtx,                                // Error collector
    pub translate_stack: Vec<AnyTransId>,               // Translation stack (cycle detection)
}
```

**Purpose Explanation**:
- `items_to_translate`: BTreeSet ensures deterministic ordering, stores items to be translated
- `processed`: Prevents translating the same item twice
- `id_map`: Records IDs of registered items for reference
- `translated`: Type is `TranslatedCrate`, responsible for storing all translation definition results, but doesn't guarantee translation order—you can't assume that translating one entity means another entity's definition is available

#### `TranslatedCrate` Structure

This type is Charon's overall translation result storage. It continuously adds entities during the translation stage, is refined, then cleaned up during the transform stage before final output. From this we can glimpse the overall structure of (U)LLBC.

???


### 4.3 enqueue vs register Mechanism

**Two Operation Modes**:

| Operation | Function | Register ID | Add to Queue | Use Case |
|-----------|----------|-------------|--------------|----------|
| enqueue | `register_and_enqueue` | ✓ | ✓ | Discover new dependencies that need translation |
| register | `register_no_enqueue` | ✓ | ✗ | Only need ID reference, no content translation |

**register_and_enqueue** (`translate_crate.rs` around line 289):
- Allocate or get ID
- Insert into `items_to_translate` queue
- Return ID for reference

**register_no_enqueue** (`translate_crate.rs` around line 329):
- Only allocate or get ID
- Don't add to translation queue
- Used for opaque items or known existing items

**Typical Call Scenarios**:
```rust
// Scenario 1: Encounter a call when translating a function
let callee_id = ctx.register_and_enqueue(span, callee_src); // Need to translate the called function

// Scenario 2: Reference an opaque external type
let type_id = ctx.register_no_enqueue(span, type_src);  // Only need ID, don't translate content
```

### 4.4 translate_item Dispatch

**Item Dispatch Flow** (`translate_items.rs` around line 13):
```rust
pub(crate) fn translate_item(&mut self, item_src: &TransItemSource) {
    ...
    match item_src.kind {
        TransItemSourceKind::Fun => { ... self.translate_function(...) },
        TransItemSourceKind::Global => { ... self.translate_global(...) },
        TransItemSourceKind::Type => { ... self.translate_type(...) },
        TransItemSourceKind::TraitDecl => { ... self.translate_trait_decl(...) },
        TransItemSourceKind::TraitImpl(_) => { ... self.translate_trait_impl(...) },
        // ...other types
    }
}
```

**RustcItem Structure**:
```rust
pub enum RustcItem {
    Poly(hax::DefId),       // Generic version
    Mono(hax::ItemRef),     // Monomorphized version
}
```

**TransItemSourceKind Classification**:
- `Fun`: Function declaration
- `Global`: Global constant/static variable
- `Type`: Type definition (struct/enum/union)
- `TraitDecl`: Trait declaration
- `TraitImpl`: Trait implementation
- `ClosureMethod`: Closure method
- ...more special types

### 4.5 The Dangerous Backdoor

In fact, besides using `enqueue` to wait for subsequent processing in the loop of the `translate_crate::translate` function, there is a **very dangerous** backdoor shortcut: the `charon_driver::translate::translate_items::get_or_translate` function.

This function will directly translate a given CharonId and return its **definition result**, rather than just registering and waiting for subsequent translation like `register_and_enqueue` does (which only returns the CharonID). The benefit is that you can **directly obtain the actual content of other definitions rather than just referencing their IDs** during the Translate stage.

However, this operation is **inherently very dangerous** because it can easily lead to circular translation in some code paths, triggering infinite recursion.

Generally speaking, the correct approach should be to use `register_and_enqueue` to register and wait for subsequent translation, rather than directly calling `get_or_translate` for immediate translation. Also, if further translation is needed, it should be done as a pass in the transform stage after all translation is complete, rather than directly during the translate stage.

> For example, when calculating the metadata type of a type pointer, you should obtain the type's definition to know whether it's a DST and whether it has a metadata type. My design for this calculation is to place a Placeholder hint during the translate stage, then replace all PlaceHolders in a pass during the transform stage, rather than directly calling `get_or_translate` for translation during the translate stage.

## 5. In-Depth Analysis of the translate Module

### 5.1 ItemTransCtx Enhanced Context

`ItemTransCtx` is the item-level translation context, managing translation state and data for **a single item**. It is created by `translate_item()` with a given `TransItemSource` and passed to the corresponding translation function according to `TransItemSourceKind`. It contains a reference to `TranslateCtx` for accessing global state.

**Item-Level Translation Context** (`translate_ctx.rs` around line 61):
```rust
pub(crate) struct ItemTransCtx<'tcx, 'ctx> {
    pub item_src: TransItemSource,              // Current translation item source
    pub item_id: Option<AnyTransId>,            // Current item ID
    pub t_ctx: &'ctx mut TranslateCtx<'tcx>,   // Global context reference
    pub error_on_impl_expr_error: bool,         // Error handling flag
    pub binding_levels: BindingStack<BindingLevel>, // Generic binding level stack
}
```

#### Detailed Field Descriptions

**1. item_src: TransItemSource**
- **Purpose**: Identifies the source of the item currently being translated
- **Content**: Contains `RustcItem` (Poly or Mono) and `TransItemSourceKind` (Fun/Type/TraitDecl, etc.)
- **Usage**: Used for error reporting, debug tracking, determining translation strategy

**2. item_id: Option<AnyTransId>**
- **Purpose**: The allocated Charon ID for the current item
- **Why Option**: Some items (like InherentImpl/Module) don't generate independent IDs
- **Usage**:
  - Reference self within translation body (recursive types)
  - Detect circular dependencies (via `translate_stack` check)
  - Used as parent reference when registering sub-items

**3. t_ctx: &'ctx mut TranslateCtx<'tcx>**
- **Purpose**: Mutable reference to access global translation context
- **Accessible Data**:
  - `translated`: Translated entity storage
  - `id_map`: Source to ID mapping
  - `items_to_translate`: Items to translate queue
  - `errors`: Error collector
- **Common Operations**:
  - `register_and_enqueue`: Register dependencies
  - `span_err`: Report errors
  - `catch_sinto`: Call Hax conversion

**4. error_on_impl_expr_error: bool**
- **Purpose**: Controls whether to treat trait implementation errors as fatal errors
- **Why Needed**: Rust doesn't enforce trait bound checks for type aliases
- **Values**:
  - `true`: Normal functions/types, strict checking
  - `false`: Inside type alias, allow incomplete trait implementation
- **Typical Scenario**:
  ```rust
  type MyType<T> = Vec<T>;  // Allowed even if T doesn't have Clone
  ```

**5. binding_levels: BindingStack<BindingLevel>**
- **Purpose**: Manage nested generic parameter binding scopes
- **Structure**: Stack, with top (index 0) being the innermost binder
- **Each Level Content** (`BindingLevel`):
  - `params: GenericParams` - Parameters bound at this level
  - `early_region_vars` - Early Bound lifetime mapping
  - `bound_region_vars` - Late Bound lifetime mapping  
  - `type_vars_map` - Type variable mapping
  - `const_generic_vars_map` - Const generic mapping
- **Operations**:
  - `push`: Enter new binder (e.g., function signature, trait declaration)
  - `pop`: Exit binder scope
  - `lookup_param`: Search for variable from top to bottom, return `DeBruijnVar`
- **Usage**:
  - Resolve generic parameter references when translating types
  - Build `DeBruijnVar` indices
  - Handle Early/Late Bound parameter differences

#### Context Creation Flow

```rust
// translate_items.rs
pub(crate) fn translate_item(&mut self, item_src: &TransItemSource) {
    // 1. Create ItemTransCtx
    let mut item_ctx = ItemTransCtx {
        item_src: item_src.clone(),
        item_id: self.id_map.get(item_src).copied(),
        t_ctx: self,
        error_on_impl_expr_error: true,  // Strict by default
        binding_levels: BindingStack::new(),
    };
    
    // 2. Dispatch based on type
    match item_src.kind {
        TransItemSourceKind::Fun => {
            item_ctx.translate_function(...);
        }
        TransItemSourceKind::Type => {
            item_ctx.translate_type(...);
        }
        // ...
    }
}
```

#### binding_levels Usage Example

```rust
// Translating function signature
fn translate_function_signature(&mut self, def: &hax::FullDef) {
    // 1. Create top-level binding
    let mut level = BindingLevel::new(is_item_binder: true);
    
    // 2. Add generic parameters
    for param in def.generics.params {
        match param.kind {
            ParamKind::Lifetime => level.push_early_region(...),
            ParamKind::Type => level.push_type_var(...),
            // ...
        }
    }
    
    // 3. Push onto stack
    self.binding_levels.push(level);
    
    // 4. Translate function body (can access parameters)
    self.translate_body(...);
    
    // 5. Exit scope
    self.binding_levels.pop();
}
```

#### Multi-Level binding_levels Scenario

```rust
// Rust code
fn outer<'a, T>(x: T) {
    fn inner<'b, U: 'b>(y: U) { ... }
    //      ^^^^^^^^^ Inner binder
}
//      ^^^^^^ Outer binder

// binding_levels stack state (when translating inner function body)
[
    BindingLevel { // index 0 - Innermost
        params: ['b, U],
        is_item_binder: true,
    },
    BindingLevel { // index 1 - Outer
        params: ['a, T],
        is_item_binder: true,
    },
]

// Lookup variable 'b -> DeBruijnVar::Bound(DeBruijnId(0), 'b)
// Lookup variable T  -> DeBruijnVar::Bound(DeBruijnId(1), T)
```

**Key Design**: `ItemTransCtx` precisely tracks generic scopes through `binding_levels`, supports the DeBruijn index system, and ensures correct translation of nested generics

### 5.2 XXDeclRef and Generic Arguments

In Charon, references to Item entities are not just IDs, but reference structures **carrying generic arguments**, such as `FunDeclRef`, which can distinguish different instantiations of the same function declaration.

**FunDeclRef Structure** (`gast.rs` around line 205):
```rust
pub struct FunDeclRef {
    pub id: FunDeclId,              // Function declaration ID
    pub generics: BoxedArgs,        // Generic arguments
}
```

**Advantages**:
- Clearly distinguish declaration vs usage
- Support multiple instantiations of the same declaration
- Carry complete type information

**Comparison**:
- Using only `FunDeclId`: Cannot distinguish `Vec<u32>` vs `Vec<String>`
- Using `FunDeclRef`: Fully records instantiation information

### 5.3 In-Depth Analysis of GenericParams and GenericArgs

**Core Concept**: `GenericParams` is the collection of formal parameters on the declaration side, `GenericArgs` is the collection of actual parameters on the usage side. Their structures correspond, with IDs mapping one-to-one.

#### Complete GenericParams Structure

**Definition Location**: `charon/src/ast/types.rs` line 248

```rust
pub struct GenericParams {
    // Three basic categories of generic parameters
    pub regions: Vector<RegionId, RegionVar>,
    pub types: Vector<TypeVarId, TypeVar>,
    pub const_generics: Vector<ConstGenericVarId, ConstGenericVar>,
    
    // Trait constraints and predicates
    pub trait_clauses: Vector<TraitClauseId, TraitClause>,
    pub regions_outlive: Vec<RegionBinder<RegionOutlives>>,
    pub types_outlive: Vec<RegionBinder<TypeOutlives>>,
    pub trait_type_constraints: Vector<TraitTypeConstraintId, RegionBinder<TraitTypeConstraint>>,
}
```

#### Field Details

**1. Basic Generic Parameters (need instantiation)**

- **`regions`**: Lifetime parameter collection
  - Type: `Vector<RegionId, RegionVar>`
  - Purpose: Store all lifetime parameters like `'a`, `'b`
  - Corresponds to `GenericArgs::regions` when instantiated

- **`types`**: Type parameter collection
  - Type: `Vector<TypeVarId, TypeVar>`
  - Purpose: Store type parameters like `T`, `U`
  - Corresponds to `GenericArgs::types` when instantiated

- **`const_generics`**: Const generic parameter collection
  - Type: `Vector<ConstGenericVarId, ConstGenericVar>`
  - Purpose: Store const parameters like `const N: usize`
  - Corresponds to `GenericArgs::const_generics` when instantiated

