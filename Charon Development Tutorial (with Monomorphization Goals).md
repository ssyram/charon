# Charon Development Architecture and Translation Tutorial

This tutorial is designed for developers who want to quickly understand and modify the Charon project's compiler intermediate representation, especially on extending the features Charon could support. It progressively explains Charon's architecture and implementation, from a high-level functional overview to some key detailed internal mechanisms.

## 1. Repository Functionality Overview

**Charon's Main Functionality**: Compile Rust crates into LLBC (Low-Level Borrow Calculus) intermediate representation or ULLBC (Unstructured LLBC) intermediate representation
- Input: Rust source code project (Cargo project or single Rust crate)
- Process: Obtain MIR through Rustc → Translate to ULLBC [→ Transform to LLBC]
- Output: (U)LLBC files in JSON format for downstream formal verification tools

**charon-ml Functionality**: Provides AST parsing for OCaml tools
- Automatically generates OCaml type definitions for the AST and JSON deserialization code
- When AST is modified in Rust, run `make generate-ml` to sync to ML
- Contains hand-written printing and name matching utilities

## 2. Complete Directory Structure

```
charon/                          # Project root directory
├── charon/                      # Rust implementation main body
│   ├── src/
│   │   ├── bin/
│   │   │   ├── charon/          # Entry executable
│   │   │   │   └── main.rs      # Main entry: set up environment and call charon-driver
│   │   │   ├── charon-driver/   # Core translation driver
│   │   │   │   ├── main.rs      # Driver entry: invoke Rustc
│   │   │   │   ├── driver.rs    # Rustc callback configuration
│   │   │   │   └── translate/   # Translation module ⭐ Most complex
│   │   │   │       ├── translate_crate.rs     # Translation dispatch main loop
│   │   │   │       ├── translate_ctx.rs       # Translation context
│   │   │   │       ├── translate_items.rs     # Item dispatching center
│   │   │   │       ├── translate_generics.rs  # Generics handling
│   │   │   │       ├── translate_functions.rs # Function (body) translation
│   │   │   │       ├── translate_types.rs     # Type translation
│   │   │   │       └── ...                    # Other translation sub-modules
│   │   │   └── generate-ml/     # Automatic ML code generator
│   │   ├── ast/                 # AST definitions
│   │   │   ├── gast.rs          # Generic AST structures
│   │   │   ├── types.rs         # Type system and generics
│   │   │   ├── llbc_ast.rs      # LLBC AST
│   │   │   └── ullbc_ast.rs     # ULLBC AST
│   │   ├── transform/           # Transformation passes
│   │   │   ├── mod.rs           # Pass registration and ordering
│   │   │   └── ...              # Various concrete cleanup passes
│   │   ├── ids/                 # Utilities for managing various kinds of IDs in Charon
│   │   ├── common.rs            # Common utilities
│   │   ├── export.rs            # Serialization output
│   │   └── lib.rs               # Library entry
│   ├── tests/                   # Rust main Test cases, for various features
│   └── Makefile
├── charon-ml/                   # OCaml implementation (downstream tool interface)
│   ├── src/
│   │   ├── generated/           # Auto-generated by `make generate-ml` (do not manually modify)
│   │   │   ├── Generated_GAst.ml
│   │   │   ├── Generated_GAstOfJson.ml
│   │   │   └── ..
│   │   ├── GAst.ml              # Hand-written AST helpers
│   │   ├── PrintGAst.ml         # Hand-written printing utilities
│   │   ├── NameMatcher.ml       # Hand-written name matching
│   │   └── ...
│   └── tests/                   # ML Test cases, mainly for deserialization & name-matching
├── docs/                        # Documentation, currently mainly overviews on functionalities and limitations
├── scripts/                     # Helper scripts
└── Makefile                     # Top-level build
```

**Key Notes**:
- The `translate/` directory has the highest complexity and contains the core translation logic
- `charon-ml/src/generated/` is auto-generated by `make generate-ml`; do not manually modify
- As a developer, after modifying the AST, one must run `make generate-ml` to sync to ML for proper deserialization

## 3. Charon's Overall Working Mechanism

### 3.1 Complete Call Flow

**Entry Flow**: `charon` → `charon-driver` → Rustc → Callback (MIR) → translate → transform

**Key Functions at Each Stage**:

1. **charon executable** (`charon/src/bin/charon/main.rs`)
   - `main()` function: Parse command-line arguments
   - Set environment variable `RUSTC_WRAPPER=charon-driver`
   - Invoke `cargo` or run Rustc directly

2. **charon-driver** (`charon/src/bin/charon-driver/main.rs`)
   - `main()` → `run_charon()` entry point
   - `driver::run_rustc_driver()` starts Rustc compilation
   > Note: This is the standard approach for Rust tool development. The compiled `charon-driver` binary acts as a Rustc wrapper. When Cargo is invoked, the Rustc used will be `charon-driver`, which first runs the normal Rustc syntax analysis pipeline and then calls callback functions at the MIR stage
   - Rustc callback configuration is in `driver.rs`

3. **driver.rs key configuration** (`charon/src/bin/charon-driver/driver.rs`)
   - `run_rustc_driver()` sets up Rustc callbacks
   - `after_expansion()` callback: the actual starting point of Charon procedures
   - Where it invokes the **key function** `translate_crate::translate()` to start the translation process

4. **Translation Dispatch** (`translate/translate_crate.rs`)
   - This stage is responsible for importing source code information from Rustc and translating it to ULLBC representation. Note that although the translation process can directly interact with Rustc, it actually introduces Hax as a **key abstraction layer** to help converting Rustc MIR into a Hax representation that is more suitable for translation needs
   > **Core Role of Hax**: Hax is an important component in Charon's architecture with the following main responsibilities:
   > 1. **Handle all Rustc queries**: Hax handles the complexity of interacting with Rustc, so Charon code doesn't need to deal with Rustc's low-level details directly
   > 2. **Handle Rustc interface changes**: Hax isolates potential changes in Rustc's interface, making Charon more robust to Rustc version updates
   > 3. **DefId abstraction**: Hax's DefId can represent either Rustc's DefId or promoted constants (the latter doesn't have an independent DefId in Rustc)
   > 4. **Trait resolution support**: Hax is responsible for creating `TraitRefKind::Clause` and `TraitRefKind::ParentClause` data. Rustc only provides `TraitDeclRef` (in Charon's terminology). I.e., in cases like `fn foo<T: Clone>`, Rustc could not tell us about the implementation of `T: Clone`, and Hax gathers these constraints as `TraitRefKind::Clause`.
   > 5. **Support polymorphic and monomorphic modes**: For scenarios that need to support both polymorphic and monomorphic translation, Hax's FullDef abstraction can uniformly handle differences between the two modes, simplifying implementation
   > 
   > It's worth noting that while theoretically possible to bypass Hax and use Rustc directly, this would bring significant additional burden, including the need to handle all the complexity of Rustc queries and interface changes ourselves. Therefore, Hax is indispensable in practice
   - `translate()` function: Main translation entry point
   - Create `TranslateCtx` context
   - Initialize, start, and manage the entire translation loop (detailed description below)

5. **(U)LLBC Transformation Stage** (back to `charon-driver/main.rs`)
   - This stage first performs ULLBC transformations, then converts to LLBC, and finally performs LLBC transformations. These transformations **do not** introduce new Rustc translation items—they don't add new information from source code, only perform further calculations on existing information, implementing normalization operations such as converting `[i]` index access to function calls
   - After translation completes in `run_charon()`
   - Iterate through and execute `transformation_passes()`
   - Finally serialize and output

### 3.2 Key Transition Point Code Examples

Here are key code snippets from each stage to help understand the overall call flow.

```rust
// Entry: charon/src/bin/charon/main.rs
fn main() {
    // Set RUSTC_WRAPPER environment variable pointing to charon-driver
    // Call cargo or rustc
}

// Driver: charon/src/bin/charon-driver/main.rs
fn run_charon(options: CliOpts) {
    let ctx = driver::run_rustc_driver(&options)?;  // ← Call Rustc
    // Execute transform passes
    for pass in transformation_passes(&options) {
        pass.run(&mut ctx);
    }
    // Potential error-handling
}

// Callback: charon/src/bin/charon-driver/driver.rs
impl Callbacks for CharonCallbacks {
    fn after_expansion(&mut self, compiler: &Compiler) {
        // Rustc expansion complete, MIR available
        let tcx = compiler.tcx();  // Get type context
        translate_crate::translate(tcx, options)  // ← Start translation
    }
}

// Translation: charon/src/bin/charon-driver/translate/translate_crate.rs
pub fn translate(tcx: TyCtxt, options: CliOpts) -> TransformCtx {
    let mut ctx = TranslateCtx::new(tcx, options);
    ctx.enqueue_module_item(...);  // Add starting items
    
    // ⭐ Core translation loop
    while let Some(item_src) = ctx.items_to_translate.pop_first() {
        ctx.translate_item(&item_src);
    }
    
    // Return context for transform
}
```

## 4. Detailed Translation Stage Flow

The translation stage is the core of Charon's capabilities, responsible for converting Rustc MIR to ULLBC. Its core is a queue-based work scheduling system that ensures all items that need translation are processed exactly once.

### 4.1 Translation Abstract Algorithm Description

**Core Loop** (`translate_crate.rs` around line 676 in function `translate`):
```rust
while let Some(item_src) = ctx.items_to_translate.pop_first() {
    if ctx.processed.insert(item_src.clone()) {
        ctx.translate_item(&item_src);
    }
}
```

**Algorithm Steps**:
1. **Initialization**: Create `TranslateCtx` with an empty `items_to_translate` queue
2. **Seed Addition**: Call `enqueue_module_item()` to add starting items (usually the crate root) to the queue
3. **Loop Processing**: Take an item from the queue and call `translate_item()` to translate it
4. **Dependency Discovery**: During translation, when dependencies are encountered (defined functions, used library functions, library types, types involved in types, etc.), they are added to the queue via `enqueue`. The main translation type here is `TransItemSource`, which contains two core fields: `RustcItem` and `TransItemSourceKind`. The former represents the specific Rustc entity being referenced (actually a Hax entity), and the latter represents the Charon target type for this entity.
> Note: One `RustcItem` may correspond to multiple `TransItemSource` instances. For example, when `RustcItem` corresponds to a specific trait, `TransItemSource` might be `Trait` representing the translation of the trait itself, or `VTable` representing the virtual table struct definition for that trait.
5. **Deduplication Check**: The `processed` set ensures each item is translated only once
6. **Completion Condition**: Translation ends when the queue is empty

### 4.2 Core Data Structure Analysis

#### `TranslateCtx` Structure

`TranslateCtx` is the core global context for the translation stage, managing **overall translation** state and data.

**Global Translation Context** (`translate/translate_ctx.rs` around line 48):
```rust
pub struct TranslateCtx<'tcx> {
    pub tcx: TyCtxt<'tcx>,                          // Rustc type context
    pub hax_state: hax::State<'tcx, Base>,          // Hax conversion state
    pub options: CliOpts,                            // Command-line options
    
    // ⭐ Translation dispatch core
    pub items_to_translate: BTreeSet<TransItemSource>,  // Items to translate queue
    pub processed: BTreeSet<TransItemSource>,           // Processed items set
    
    // Registration and storage
    pub id_map: HashMap<TransItemSource, AnyTransId>,   // Source -> ID mapping
    pub translated: TranslatedCrate,                     // Translation result storage
    
    // Error handling
    pub errors: ErrorCtx,                                // Error collector
    pub translate_stack: Vec<AnyTransId>,               // Translation stack (cycle detection)
}
```

**Purpose Explanation**:
- `items_to_translate`: BTreeSet ensures deterministic ordering, stores items to be translated
- `processed`: Prevents translating the same item twice
- `id_map`: Records IDs of registered items for reference
- `translated`: Type is `TranslatedCrate`, responsible for storing all translation definition results, but doesn't guarantee translation order—you can't assume that translating one entity means another entity's definition is available

#### `TranslatedCrate` Structure

This type is Charon's overall translation result storage. It continuously adds entities during the translation stage, is refined, then cleaned up during the transform stage before final output. From this we can glimpse the overall structure of (U)LLBC.

```rust
pub struct TranslatedCrate {
    // Metadata
    pub crate_name: String,                     // Crate name
    pub options: crate::options::CliOpts,       // CLI options, take effect during the translating stage
    pub target_information: TargetInfo,         // Target platform information, e.g., pointer size, endianness, etc.
    
    // Name mappings
    pub item_names: HashMap<ItemId, Name>,      // Full names for all items (even failed translations)
    pub short_names: HashMap<ItemId, Name>,     // Short names where the last PathElem is unique
    
    // Translation (temporary) results
    pub files: Vector<FileId, File>,                        // Source files
    pub type_decls: Vector<TypeDeclId, TypeDecl>,           // Type definitions (struct/enum/union)
    pub fun_decls: Vector<FunDeclId, FunDecl>,              // Function definitions
    pub global_decls: Vector<GlobalDeclId, GlobalDecl>,     // Global constants and static variables
    pub trait_decls: Vector<TraitDeclId, TraitDecl>,        // Trait declarations
    pub trait_impls: Vector<TraitImplId, TraitImpl>,        // Trait implementations
    
    // Special items
    pub unit_metadata: Option<GlobalDeclRef>,               // `const UNIT: () = ();` for thin pointer/reference metadata
    pub ordered_decls: Option<DeclarationsGroups>,          // Re-ordered declaration groups (initialized during transform stage)
}
```

**Key Design Points**:
- Uses `Vector<Id, T>` (essentially `IndexVec<Id, Option<T>>`) to allow IDs to exist before their content is filled
  When registering an item, it allocates an ID and reserves a slot in the vector (as `None`), then fills in the content after translation
- `ItemId` enum unifies all item types: `Type | Fun | Global | TraitDecl | TraitImpl`


### 4.3 enqueue vs register Mechanism

**Two Operation Modes**:

| Operation | Function | Register ID | Add to Queue | Use Case |
|-----------|----------|-------------|--------------|----------|
| enqueue | `register_and_enqueue` | ✓ | ✓ | Discover new dependencies that need translation |
| register | `register_no_enqueue` | ✓ | ✗ | Only need ID reference, no content translation (* may still be translated if enqueued in other places) |

**register_and_enqueue** (`translate_crate.rs` around line 289):
- Allocate or get ID
- Insert into `items_to_translate` queue
- Return ID for reference

**register_no_enqueue** (`translate_crate.rs` around line 329):
- Only allocate or get ID
- Don't add to translation queue
- Used for opaque items or known existing items

### 4.4 translate_item Dispatch

**Item Dispatch Flow** (`translate_items.rs` around line 13):
```rust
pub(crate) fn translate_item(&mut self, item_src: &TransItemSource) {
    ...
    match item_src.kind {
        TransItemSourceKind::Fun => { ... self.translate_function(...) },
        TransItemSourceKind::Global => { ... self.translate_global(...) },
        TransItemSourceKind::Type => { ... self.translate_type(...) },
        TransItemSourceKind::TraitDecl => { ... self.translate_trait_decl(...) },
        TransItemSourceKind::TraitImpl(_) => { ... self.translate_trait_impl(...) },
        // ...other types
    }
}
```

**RustcItem Structure**:
```rust
pub enum RustcItem {
    Poly(hax::DefId),       // Generic version
    Mono(hax::ItemRef),     // Monomorphized version
}
```

**TransItemSourceKind Classification**:
- `Fun`: Function declaration
- `Global`: Global constant/static variable
- `Type`: Type definition (struct/enum/union)
- `TraitDecl`: Trait declaration
- `TraitImpl`: Trait implementation
- `ClosureMethod`: Closure method
- ...more special types

### 4.5 The Dangerous Backdoor

In fact, besides using `enqueue` to wait for subsequent processing in the loop of the `translate_crate::translate` function, there is a **dangerous** backdoor shortcut: the `charon_driver::translate::translate_items::get_or_translate` function.

This function will directly translate a given CharonId and return its **definition result**, rather than just registering and waiting for subsequent translation like `register_and_enqueue` does (which only returns the CharonID). The benefit is that one can **directly obtain the actual content of other definitions rather than just referencing their IDs** during the Translate stage.

However, this operation is **inherently dangerous** because it may somehow lead to circular translation in some code paths.

Generally speaking, the recommended approach should be to use `register_and_enqueue` to register and wait for subsequent translation, rather than directly calling `get_or_translate` for immediate translation. Also, if further translation is needed, it should be done as a pass in the transform stage after all translation is complete, rather than directly during the translate stage.

> For example, when calculating the metadata type of a type pointer, one should obtain the type's definition to know whether it's a DST and whether it has a metadata type. My design for this calculation is to place a Placeholder hint during the translate stage, then replace all PlaceHolders in a pass during the transform stage, rather than directly calling `get_or_translate` for translation during the translate stage.

## 5. In-Depth Analysis of the translate Module

### 5.1 ItemTransCtx Enhanced Context

`ItemTransCtx` is the item-level translation context, managing translation state and data for **a single item**. It is created by `translate_item()` with a given `TransItemSource` and passed to the corresponding translation function according to `TransItemSourceKind`. It contains a reference to `TranslateCtx` for accessing global state.

**Item-Level Translation Context** (`translate_ctx.rs` around line 61):
```rust
pub(crate) struct ItemTransCtx<'tcx, 'ctx> {
    pub item_src: TransItemSource,              // Current translation item source
    pub item_id: Option<AnyTransId>,            // Current item ID
    pub t_ctx: &'ctx mut TranslateCtx<'tcx>,   // Global context reference
    pub error_on_impl_expr_error: bool,         // Error handling flag
    pub binding_levels: BindingStack<BindingLevel>, // Generic binding level stack
}
```

#### Detailed Field Descriptions

**1. item_src: TransItemSource**
- **Purpose**: Identifies the source of the item currently being translated
- **Content**: Contains `RustcItem` (Poly or Mono) and `TransItemSourceKind` (Fun/Type/TraitDecl, etc.)
- **Usage**: Used for error reporting, debug tracking, determining translation strategy

**2. item_id: Option<AnyTransId>**
- **Purpose**: The allocated Charon ID for the current item
- **Why Option**: Some items (like InherentImpl/Module) don't generate independent IDs
- **Usage**:
  - Reference self within translation body (recursive types)
  - Detect circular dependencies (via `translate_stack` check)
  - Used as parent reference when registering sub-items

**3. t_ctx: &'ctx mut TranslateCtx<'tcx>**
- **Purpose**: Mutable reference to access global translation context
- **Accessible Data**:
  - `translated`: Translated entity storage
  - `id_map`: Source to ID mapping
  - `items_to_translate`: Items to translate queue
  - `errors`: Error collector
- **Common Operations**:
  - `register_and_enqueue`: Register dependencies
  - `span_err`: Report errors
  - `catch_sinto`: Call Hax conversion

**4. error_on_impl_expr_error: bool**
- **Purpose**: Controls whether to treat trait implementation errors as fatal errors
- **Why Needed**: Rust doesn't enforce trait bound checks for type aliases
- **Values**:
  - `true`: Normal functions/types, strict checking
  - `false`: Inside type alias, allow incomplete trait implementation
- **Typical Scenario**:
  ```rust
  type MyType<T> = Vec<T>;  // Allowed even if T doesn't have Clone
  ```

**5. binding_levels: BindingStack<BindingLevel>**
- **Purpose**: Manage nested generic parameter binding scopes
- **Structure**: Stack, with top (index 0) being the innermost binder
- **Each Level Content** (`BindingLevel`):
  - `params: GenericParams` - Parameters bound at this level
  - `early_region_vars` - Early Bound lifetime mapping
  - `bound_region_vars` - Late Bound lifetime mapping  
  - `type_vars_map` - Type variable mapping
  - `const_generic_vars_map` - Const generic mapping
- **Operations**:
  - `push`: Enter new binder (e.g., function signature, trait declaration)
  - `pop`: Exit binder scope
  - `lookup_param`: Search for variable from top to bottom, return `DeBruijnVar`
- **Usage**:
  - Resolve generic parameter references when translating types
  - Build `DeBruijnVar` indices
  - Handle Early/Late Bound parameter differences

#### Context Creation Flow

```rust
// translate_items.rs
pub(crate) fn translate_item(&mut self, item_src: &TransItemSource) {
    // 1. Create ItemTransCtx
    let mut item_ctx = ItemTransCtx {
        item_src: item_src.clone(),
        item_id: self.id_map.get(item_src).copied(),
        t_ctx: self,
        error_on_impl_expr_error: true,  // Strict by default
        binding_levels: BindingStack::new(),
    };
    
    // 2. Dispatch based on type
    match item_src.kind {
        TransItemSourceKind::Fun => {
            item_ctx.translate_function(...);
        }
        TransItemSourceKind::Type => {
            item_ctx.translate_type(...);
        }
        // ...
    }
}
```

#### binding_levels Usage Example

```rust
// Translating function signature
fn translate_function_signature(&mut self, def: &hax::FullDef) {
    // 1. Create top-level binding
    let mut level = BindingLevel::new(is_item_binder: true);
    
    // 2. Add generic parameters
    for param in def.generics.params {
        match param.kind {
            ParamKind::Lifetime => level.push_early_region(...),
            ParamKind::Type => level.push_type_var(...),
            // ...
        }
    }
    
    // 3. Push onto stack
    self.binding_levels.push(level);
    
    // 4. Translate function body (can access parameters)
    self.translate_body(...);
    
    // 5. Exit scope
    self.binding_levels.pop();
}
```

#### Multi-Level binding_levels Scenario

```rust
// Rust code
fn outer<'a, T>(x: T) {
    fn inner<'b, U: 'b>(y: U) { ... }
    //      ^^^^^^^^^ Inner binder
}
//      ^^^^^^ Outer binder

// binding_levels stack state (when translating inner function body)
[
    BindingLevel { // index 0 - Innermost
        params: ['b, U],
        is_item_binder: true,
    },
    BindingLevel { // index 1 - Outer
        params: ['a, T],
        is_item_binder: true,
    },
]

// Lookup variable 'b -> DeBruijnVar::Bound(DeBruijnId(0), 'b)
// Lookup variable T  -> DeBruijnVar::Bound(DeBruijnId(1), T)
```

**Key Design**: `ItemTransCtx` precisely tracks generic scopes through `binding_levels`, supports the DeBruijn index system, and ensures correct translation of nested generics

### 5.2 XXDeclRef and Generic Arguments

In Charon, references to Item entities are not just IDs, but reference structures **carrying generic arguments**, such as `FunDeclRef`, which can distinguish different instantiations of the same function declaration.

**FunDeclRef Structure** (`gast.rs` around line 205):
```rust
pub struct FunDeclRef {
    pub id: FunDeclId,              // Function declaration ID
    pub generics: BoxedArgs,        // Generic arguments
}
```

**Advantages**:
- Clearly distinguish declaration vs usage
- Support multiple instantiations of the same declaration
- Carry complete type information

**Comparison**:
- Using only `FunDeclId`: Cannot distinguish `Vec<u32>` vs `Vec<String>`
- Using `FunDeclRef`: Fully records instantiation information

### 5.3 In-Depth Analysis of GenericParams and GenericArgs

**Core Concept**: `GenericParams` is the collection of formal parameters on the declaration side, `GenericArgs` is the collection of actual parameters on the usage side. Their structures correspond, with IDs mapping one-to-one.

#### Complete GenericParams Structure

**Definition Location**: `charon/src/ast/types.rs` line 248

```rust
pub struct GenericParams {
    // Three basic categories of generic parameters
    pub regions: Vector<RegionId, RegionVar>,
    pub types: Vector<TypeVarId, TypeVar>,
    pub const_generics: Vector<ConstGenericVarId, ConstGenericVar>,
    
    // Trait constraints and predicates
    pub trait_clauses: Vector<TraitClauseId, TraitClause>,
    pub regions_outlive: Vec<RegionBinder<RegionOutlives>>,
    pub types_outlive: Vec<RegionBinder<TypeOutlives>>,
    pub trait_type_constraints: Vector<TraitTypeConstraintId, RegionBinder<TraitTypeConstraint>>,
}
```

#### Field Details

**1. Basic Generic Parameters (need instantiation)**

- **`regions`**: Lifetime parameter collection
  - Type: `Vector<RegionId, RegionVar>`
  - Purpose: Store all lifetime parameters like `'a`, `'b`
  - Corresponds to `GenericArgs::regions` when instantiated

- **`types`**: Type parameter collection
  - Type: `Vector<TypeVarId, TypeVar>`
  - Purpose: Store type parameters like `T`, `U`
  - Corresponds to `GenericArgs::types` when instantiated

- **`const_generics`**: Const generic parameter collection
  - Type: `Vector<ConstGenericVarId, ConstGenericVar>`
  - Purpose: Store const parameters like `const N: usize`
  - Corresponds to `GenericArgs::const_generics` when instantiated

**2. trait_clauses - Trait Constraint Clauses**

**Type**: `Vector<TraitClauseId, TraitClause>`

**Purpose**: Store trait constraints, i.e., trait bounds in `where` clauses

**TraitClause Structure** (`types/vars.rs`):
```rust
pub struct TraitClause {
    pub clause_id: TraitClauseId,        // Clause ID
    pub span: Option<Span>,              // Source code location
    pub origin: PredicateOrigin,         // Constraint origin
    pub trait_: PolyTraitDeclRef,        // Implemented trait
}
```

**Example**:
```rust
fn process<T: Clone + Display>(x: T) { ... }
```
Corresponds to two trait_clauses:
- Clause 0: `T: Clone`
- Clause 1: `T: Display`

When instantiated, `GenericArgs::trait_refs` provides the specific trait implementation reference for each clause

**3. regions_outlive - Lifetime Outlives Constraints**

**Type**: `Vec<RegionBinder<RegionOutlives>>`

**Purpose**: Express outlives relationships between lifetimes (`'a: 'b` means `'a` outlives `'b`)

**RegionOutlives Definition**:
```rust
pub type RegionOutlives = OutlivesPred<Region, Region>;
pub struct OutlivesPred<T, U>(pub T, pub U);  // T outlives U
```

**Example**:
```rust
fn foo<'a, 'b: 'a>(x: &'a str, y: &'b str) { ... }
//        ^^^^^^ Indicates 'b: 'a, i.e., 'b outlives 'a
```
Corresponds to one `regions_outlive` entry: `OutlivesPred('b, 'a)`

**Why `RegionBinder`**: Constraints may introduce new local lifetimes (like `for<'c>`), requiring a binder wrapper

**4. types_outlive - Type Outlives Constraints**

**Type**: `Vec<RegionBinder<TypeOutlives>>`

**Purpose**: Express outlives relationships of types to lifetimes

**TypeOutlives Definition**:
```rust
pub type TypeOutlives = OutlivesPred<Ty, Region>;
// First is type, second is lifetime
```

**Example**:
```rust
fn bar<'a, T: 'a>(data: T) { ... }
//        ^^^^^ Indicates T: 'a, i.e., all references in T live at least 'a
```
Corresponds to one `types_outlive` entry: `OutlivesPred(T, 'a)`

**Practical Use**: Ensure references in generic types satisfy lifetime requirements

**5. trait_type_constraints - Trait Associated Type Constraints**

**Type**: `Vector<TraitTypeConstraintId, RegionBinder<TraitTypeConstraint>>`

**Purpose**: Constrain a trait's associated type to a specific type

**TraitTypeConstraint Structure** (`types.rs` line 176):
```rust
pub struct TraitTypeConstraint {
    pub trait_ref: TraitRef,      // Trait reference
    pub type_name: TraitItemName, // Associated type name
    pub ty: Ty,                   // Constrained concrete type
}
```

**Example**:
```rust
fn process<T>(x: T) 
where 
    T: Iterator<Item = String>
    //          ^^^^^^^^^^^^^^ This is a trait_type_constraint
{
    ...
}
```

**Breakdown**:
- `trait_ref`: Points to the `Iterator` trait
- `type_name`: `Item` (associated type name)
- `ty`: `String` (constraint type)

**More Complex Example**:
```rust
trait Container {
    type Elem;
    type Iter: Iterator;
}

fn complex<C>(c: C) 
where 
    C: Container<Elem = i32, Iter = std::vec::IntoIter<i32>>
    //          ^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //          Constraint 1   Constraint 2
{
    ...
}
```

Generates two `trait_type_constraints`:
1. `Container::Elem = i32`
2. `Container::Iter = std::vec::IntoIter<i32>`

**Why Separate from trait_clauses**: Associated type constraints are not simple trait bounds, but equality constraints on types inside traits. They require recording a triple `(trait, assoc_type_name, concrete_type)`

#### Complete GenericArgs Structure

**Definition Location**: `charon/src/ast/types.rs` line 184

```rust
pub struct GenericArgs {
    pub regions: Vector<RegionId, Region>,
    pub types: Vector<TypeVarId, Ty>,
    pub const_generics: Vector<ConstGenericVarId, ConstGeneric>,
    pub trait_refs: Vector<TraitClauseId, TraitRef>,
}
```

#### GenericArgs Field Details

**1-3. Basic Parameter Arguments**

- **`regions`**: Lifetime arguments, corresponding to `GenericParams::regions`
- **`types`**: Type arguments, corresponding to `GenericParams::types`
- **`const_generics`**: Const arguments, corresponding to `GenericParams::const_generics`

**4. trait_refs - Trait Implementation References**

**Type**: `Vector<TraitClauseId, TraitRef>`

**Purpose**: Provide concrete trait implementation for each clause in `GenericParams::trait_clauses`

**TraitRef Structure** (`types.rs` line 130):
```rust
pub struct TraitRef {
    pub kind: TraitRefKind,           // Implementation source
    pub trait_decl_ref: PolyTraitDeclRef, // Trait declaration reference
}
```

**Mapping Relationship**:
- `GenericParams::trait_clauses[i]` declares "needs a certain trait"
- `GenericArgs::trait_refs[i]` provides "which specific implementation satisfies this trait"

**Example**:
```rust
// Declaration
fn sort<T: Ord>(items: &mut [T]) { ... }
//      GenericParams::trait_clauses[0] = T: Ord

// Call
sort::<String>(&mut data);
//     GenericArgs::types[0] = String
//     GenericArgs::trait_refs[0] = impl Ord for String
```

#### Complete Example

**Rust Code**:
```rust
trait Container {
    type Item;
}

fn process<'a, T, const N: usize>(data: &'a [T; N]) 
where
    T: Clone + Container<Item = String>,
    T: 'a,
{
    ...
}

// Call
process::<'static, Vec<u8>, 10>(&array);
```

**GenericParams Content**:
```rust
GenericParams {
    regions: ['a],
    types: [T],
    const_generics: [N: usize],
    trait_clauses: [
        Clause(0): T: Clone,
        Clause(1): T: Container,
    ],
    types_outlive: [
        T: 'a,
    ],
    trait_type_constraints: [
        Container::Item = String,
    ],
    regions_outlive: [],
}
```

**GenericArgs Content**:
```rust
GenericArgs {
    regions: ['static],
    types: [Vec<u8>],
    const_generics: [10],
    trait_refs: [
        TraitRef(0): impl Clone for Vec<u8>,
        TraitRef(1): impl Container for Vec<u8>,
    ],
}
```

#### Design Philosophy

Similar to Dependent Type systems, it explicitly requires providing "implementation proof", i.e., `TraitRef` to satisfy `TraitClause` constraints.

**Vector Data Structure**: `Vector<Id, T>` is Charon's internal indexed collection data structure, using ID as index for direct access. Used for parameters, where an Id can be just a Placeholder without actual content, corresponding to registered but not yet filled cases. Internally uses `IndexVec<I, Option<T>>`.

### 5.4 DeBruijnIndex System

**Definition** (`types/vars.rs` around line 31):
```rust
pub struct DeBruijnId {
    pub index: usize,  // Count from inner to outer, 0 means innermost
}
```

**DeBruijnVar Structure**:
```rust
pub enum DeBruijnVar<Id> {
    Bound(DeBruijnId, Id),  // Bound variable: (level, variable ID)
    Free(Id),                // Free variable: top-level parameter
}
```

**Nesting Example**:
```rust
fn f<'a>(                              // Level 2
    x: for<'b> fn(                     // Level 1
        for<'c> fn(&'a u8, &'b u16, &'c u32)  // Level 0
    )
) {}
```
Reference representation:
- `'c`: `Bound(0, c)` - Innermost
- `'b`: `Bound(1, b)` - Middle
- `'a`: `Free(a)` - Top-level (after `unbind_item_vars` pass)

See `charon/src/ast/types/vars.rs` for more details with comprehensive DeBruijn variable usage examples:
```rust
fn f<'a, 'b>(x: for<'c> fn(&'b u8, &'c u16, for<'d> fn(&'b u32, &'c u64, &'d u128)) -> u64) {}
     ^^^^^^         ^^       ^       ^          ^^       ^        ^        ^
       |       inner binder  |       |     inner binder  |        |        |
 top-level binder            |       |                   |        |        |
                       Bound(1, b)   |              Bound(2, b)   |     Bound(0, d)
                                     |                            |
                                 Bound(0, c)                 Bound(1, c)
```

Here we can see that `'b` is referenced at two different nesting levels, corresponding to different `DeBruijnId` values. For example, the right reference `&'b u32` corresponds to `Bound(2, b)` because it must cross two binders `for<'d>` and `for<'c>` to reach the definition of `'b`.

In fact, `'a` and `'b` are both in the same binding_levels, so `DeBruijnVar` actually has two variables: the first is DeBruijnId, and the second is the **left-to-right** index within the same Binding. So the second `&'b u32` should actually be `DeBruijnVar::Bound(2, 1)`.

> For Eurydice using the (U)LLBC side, references to `'b` will be `DeBruijnVar::Free(1)`. This is after transformation in the Transform stage, but during the Translate stage it's still `DeBruijnVar::Bound(2, 1)`. Making the top-level definition `Free` is for easier backend processing.

### 5.5 Binder vs RegionBinder

A Binder is a binder inside an Item. `Binder<K>` refers to binding a series of new generic parameters to a `K` type object. It appears where generic parameters need to be bound, such as trait methods, trait associated types, dyn types, function pointer types, etc.

For example:
```rust
trait MyTrait {
    type AssocType<'a>;  // 'a here is a Binder
    fn method<T>(&self, x: T);  // T here is a Binder
}
```

For trait objects, when they reference their own `method` method, `T` is an unknown type, so a `Binder` is needed to represent that `T` is a generic parameter. The same situation occurs with the associated type `AssocType`. So in `TraitDecl`, the data types for associated types and associated methods lists are both `Binder<...>`:
```rust
pub types: Vec<Binder<TraitAssocTy>>,
....
pub methods: Vec<Binder<TraitMethod>>,
```

> Note: Readers from functional programming backgrounds might mistakenly think `Binder<T>` is analogous to `lambda (x : T). E`, i.e., the bound parameter itself is of type `T`. But actually `Binder<T>` should be analogous to `lambda (X : GenericParam). (E : T)`, where `T` is the type of the internal expression, and the bound parameter type is always `GenericParam`.

On the other hand, `RegionBinder` is a special case of `Binder` that only binds lifetime parameters. `RegionBinder` is Charon's own creation; in Rustc all binders are `Binder`, but in Charon using `RegionBinder` for lifetime parameter binders can more clearly express the semantics of binding only lifetime parameters. Because in many places (especially Late Bound lifetime parameters mentioned below) only lifetime parameters can be bound, using `RegionBinder` avoids misusing `Binder` to bind type or const parameters.

> For example, in function pointer `fn<...>(Args) -> Ret`, `...` can only be lifetime parameters, so the function pointer type in `TyKind` is: `FnPtr(RegionBinder<(Vec<Ty>, Ty)>),`

**RegionBinder** (`types.rs` around line 198):
```rust
pub struct RegionBinder<T> {
    pub regions: Vector<RegionId, RegionVar>,  // Only bind lifetimes
    pub skip_binder: T,
}
```

**Binder** (`types.rs` around line 227):
```rust
pub struct Binder<T> {
    pub params: GenericParams,  // Bind complete generic parameters
    pub skip_binder: T,
    pub kind: BinderKind,
}
```

**Usage Scenarios**:
- `RegionBinder`: `for<'a>` function pointer types
- `Binder`: Trait methods (may have type parameters)

### 5.6 Early Bound, Late Bound Generics and Monomorphization Handling

In Rustc, there's a distinction between Early Bound and Late Bound. Early Bound generic parameters are item-level generic parameters like `<T>`, while Late Bound generic parameters are locally quantified lifetime parameters in the form `for<'a>`.

However, Charon does not distinguish between Early Bound and Late Bound; it only requires that Late Bound always comes **after** Early Bound. Charon's monomorphization framework only monomorphizes Early Bound parameters. Late Bound parameters will likely be retained in the definition, and Late Bound can only be lifetime parameters. In other words: even with monomorphic translation, you may still encounter situations where Late Bound lifetime parameters need to be handled.


### 5.7 Function Translation Flow

When translating functions, generics are automatically handled through `translate_function_signature`, so there's no need to call `translate_def_generics` separately. Details below:

**Complete Path**:
```
Rustc MIR 
  ↓ Hax conversion
Hax MIR
  ↓ translate_function_signature (translate_functions.rs)
Signature (parameters/return type)
  ↓ translate_def_generics (translate_generics.rs)
Generic environment setup
  ↓ translate_body (translate_bodies.rs)
Function body -> ULLBC
```

**Key Functions**:
- `translate_function_signature`: Handle signature and generics
- `translate_body`: Convert MIR basic blocks to ULLBC
- `translate_statement`: Single statement translation
- `translate_operand`/`translate_place`: Expression components

### 5.8 Line-by-Line Explanation of translate_def_generics Function (AI Explanation, Preliminarily Checked for Reasonableness)

**Location**: `charon/src/bin/charon-driver/translate/translate_generics.rs` line 433

This is the core entry function for generic handling, responsible for establishing a complete generic parameter environment so that subsequent type translation can correctly resolve generic references.

#### Function Overview

```rust
pub(crate) fn translate_def_generics(
    &mut self,
    span: Span,
    def: &hax::FullDef,
) -> Result<(), Error> {
    assert!(self.binding_levels.len() == 0);
    self.binding_levels.push(BindingLevel::new(true));
    self.push_generics_for_def(span, def, false)?;
    self.innermost_binder_mut().params.check_consistency();
    Ok(())
}
```

**Core Responsibilities**:
1. Ensure clean initial state (binding_levels is empty)
2. Create top-level binder (item-level binder)
3. Recursively collect generic parameters of the item and its parents
4. Verify generic parameter consistency

**Call Timing**: When translating an item's signature, before translating types and body

#### Line-by-Line Analysis

**Line 438: Initial State Assertion**
```rust
assert!(self.binding_levels.len() == 0);
```
- **Purpose**: Ensure binding_levels stack is empty
- **Reason**: This function establishes the top-level environment and should not have existing binders
- **Failure Scenario**: If the function is called repeatedly or in a nested context

**Line 439: Create Top-Level Binder**
```rust
self.binding_levels.push(BindingLevel::new(true));
```
- **`BindingLevel::new(true)`**:
  - Parameter `true` means `is_item_binder = true`
  - Marks this as an item-level binder (corresponding to Rustc's ParamEnv)
  - Distinguished from local binders (like `for<'a>`)
- **Result**: `binding_levels` stack depth becomes 1
- **Next**: This level will be filled with all the item's generic parameters

**Line 440: Collect Generic Parameters (Core Recursive Call)**
```rust
self.push_generics_for_def(span, def, false)?;
```

This is the most critical step, calling `push_generics_for_def` to recursively collect generics. Let's analyze this function in depth.

#### In-Depth Analysis of push_generics_for_def

**Location**: Same file, line 337

```rust
fn push_generics_for_def(
    &mut self,
    span: Span,
    def: &hax::FullDef,
    is_parent: bool,
) -> Result<(), Error> {
    // Lines 345-348: Recursively process parent item generics
    if let Some(parent_item) = def.typing_parent(self.hax_state()) {
        let parent_def = self.hax_def(&parent_item)?;
        self.push_generics_for_def(span, &parent_def, true)?;
    }
    // Line 349: Process current item generics
    self.push_generics_for_def_without_parents(span, def, !is_parent)?;
    Ok(())
}
```

**Execution Flow**:

1. **Parent Generics Collection (Lines 345-348)**:
   - `def.typing_parent()`: Get typing parent (different from syntactic parent)
   - **Example**: The parent of a trait method is the trait declaration
   - Recursive call ensures parent generics come before child generics
   - `is_parent: true`: Mark as parent processing mode

2. **Current Item Generics Collection (Line 349)**:
   - Call `push_generics_for_def_without_parents`
   - `!is_parent`: Third parameter becomes `include_late_bound`
   - **Key**: Only top-level items (`is_parent=false`) include Late Bound parameters

**Parent Generics Example**:
```rust
trait Container<T> {
    fn process<U>(&self, item: U) -> T;
    //         ^^ Method's own generic
    //    ^^^^^^^^ Inherited from trait
}
```
When processing `process`:
1. First recursively collect `Container<T>`
2. Then collect `process<U>`
3. Final GenericParams: `[T, U]`

#### Detailed push_generics_for_def_without_parents

**Location**: Same file, line 355

```rust
fn push_generics_for_def_without_parents(
    &mut self,
    _span: Span,
    def: &hax::FullDef,
    include_late_bound: bool,
) -> Result<(), Error> {
    // Lines 362-384: Handle ParamEnv (Early Bound parameters and predicates)
    if let Some(param_env) = def.param_env() {
        self.push_generic_params(&param_env.generics)?;
        let origin = match &def.kind { ... };
        self.register_predicates(&param_env.predicates, origin.clone())?;
    }
    
    // Lines 386-403: Handle closure upvar lifetimes
    if let hax::FullDefKind::Closure { args, .. } = def.kind()
        && include_late_bound
    { ... }
    
    // Lines 413-424: Handle Late Bound lifetimes
    if let Some(signature) = signature
        && include_late_bound
    { ... }
    
    Ok(())
}
```

**Execution Stages**:

**Stage 1: Early Bound Parameter Collection (Lines 362-365)**
```rust
if let Some(param_env) = def.param_env() {
    self.push_generic_params(&param_env.generics)?;
    // ...
}
```
- `param_env()`: Rustc's ParamEnv, contains Early Bound generics
- `push_generic_params`: Iterate and add parameters

**push_generic_params Implementation (Line 291)**:
```rust
pub(crate) fn push_generic_params(&mut self, generics: &hax::TyGenerics) -> Result<(), Error> {
    for param in &generics.params {
        self.push_generic_param(param)?;
    }
    Ok(())
}
```

**push_generic_param Implementation (Lines 298-332)**:
```rust
pub(crate) fn push_generic_param(&mut self, param: &hax::GenericParamDef) -> Result<(), Error> {
    match &param.kind {
        hax::GenericParamDefKind::Lifetime => {
            let region = hax::EarlyParamRegion {
                index: param.index,
                name: param.name.clone(),
            };
            let _ = self.innermost_binder_mut().push_early_region(region);
        }
        hax::GenericParamDefKind::Type { .. } => {
            let _ = self
                .innermost_binder_mut()
                .push_type_var(param.index, param.name.clone());
        }
        hax::GenericParamDefKind::Const { ty, .. } => {
            // Translate const type
            let ty = self.translate_ty(span, ty)?;
            match ty.kind().as_literal() {
                Some(ty) => self.innermost_binder_mut().push_const_generic_var(
                    param.index,
                    *ty,
                    param.name.clone(),
                ),
                None => raise_error!(...),
            }
        }
    }
    Ok(())
}
```

**Parameter Addition Details**:
- **Lifetime**: Call `push_early_region`
  - Add to `params.regions`
  - Record in `early_region_vars` mapping (Rust index → Charon RegionId)
- **Type**: Call `push_type_var`
  - Add to `params.types`
  - Record in `type_vars_map`
- **Const**: Call `push_const_generic_var`
  - Must first translate type (must be literal type)
  - Add to `params.const_generics`
  - Record in `const_generic_vars_map`

**Stage 2: Predicate Registration (Lines 366-383)**
```rust
let origin = match &def.kind {
    FullDefKind::Adt { .. } | FullDefKind::TyAlias { .. } | FullDefKind::AssocTy { .. } 
        => PredicateOrigin::WhereClauseOnType,
    FullDefKind::Fn { .. } | FullDefKind::AssocFn { .. } | ...
        => PredicateOrigin::WhereClauseOnFn,
    FullDefKind::TraitImpl { .. } | FullDefKind::InherentImpl { .. } 
        => PredicateOrigin::WhereClauseOnImpl,
    FullDefKind::Trait { .. } | FullDefKind::TraitAlias { .. } 
        => PredicateOrigin::WhereClauseOnTrait,
    _ => panic!("Unexpected def: {def:?}"),
};
self.register_predicates(&param_env.predicates, origin.clone())?;
```

- **origin determination**: Determine predicate source based on item type
- **register_predicates**: Translate and add predicates to `GenericParams`
  - trait_clauses
  - regions_outlive
  - types_outlive
  - trait_type_constraints

**Stage 3: Closure upvar Lifetimes (Lines 386-403)**
```rust
if let hax::FullDefKind::Closure { args, .. } = def.kind()
    && include_late_bound
{
    args.upvar_tys.iter().for_each(|ty| {
        if matches!(
            ty.kind(),
            hax::TyKind::Ref(
                hax::Region { kind: hax::RegionKind::ReErased },
                ..
            )
        ) {
            self.the_only_binder_mut().push_upvar_region();
        }
    });
}
```

- **Special handling**: Closures' by-ref upvars introduce additional lifetimes
- **Detection**: Look for upvars with type `&'erased T`
- **Addition**: Call `push_upvar_region` to add anonymous lifetime

**Stage 4: Late Bound Lifetimes (Lines 413-424)**
```rust
let signature = match &def.kind {
    hax::FullDefKind::Fn { sig, .. } => Some(sig),
    hax::FullDefKind::AssocFn { sig, .. } => Some(sig),
    _ => None,
};
if let Some(signature) = signature
    && include_late_bound
{
    let innermost_binder = self.innermost_binder_mut();
    assert!(innermost_binder.bound_region_vars.is_empty());
    innermost_binder.push_params_from_binder(signature.rebind(()))?;
}
```

- **Applicable**: Only functions have Late Bound parameters
- **Extraction**: Extract binder from function signature
- **Addition**: `push_params_from_binder` iterates and adds
- **Assertion**: Ensure `bound_region_vars` was previously empty (Late Bound added last)

**push_params_from_binder Implementation (Line 120)**:
```rust
pub(crate) fn push_params_from_binder(&mut self, binder: hax::Binder<()>) -> Result<(), Error> {
    assert!(
        self.bound_region_vars.is_empty(),
        "Trying to use two binders at the same binding level"
    );
    use hax::BoundVariableKind::*;
    for p in binder.bound_vars {
        match p {
            Region(region) => {
                self.push_bound_region(region);
            }
            Ty(_) => {
                panic!("Unexpected locally bound type variable");
            }
    Ok(())
}
```

#### Back to translate_def_generics

**Line 441: Consistency Check**
```rust
self.innermost_binder_mut().params.check_consistency();
```
- **Purpose**: Verify internal consistency of GenericParams
- **Checks**:
  - Vector sizes match
  - ID ordering is correct
  - No duplicate references

**Line 442: Success Return**
```rust
Ok(())
```

#### Complete Execution Example

**Rust Code**:
```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

impl<T: Clone> Iterator for Vec<T> {
    type Item = T;
    fn next(&mut self) -> Option<T> { ... }
}
```

**Execution Flow When Translating `Vec<T>::next`**:

1. **translate_def_generics Entry**
   - `binding_levels` initially empty
   - Create top-level BindingLevel

2. **push_generics_for_def**
   - Detect parent: `impl<T: Clone> Iterator for Vec<T>`
   - Recursive call to process impl block

3. **Process impl Block Generics**
   - `push_generic_params`: Add `T`
   - `register_predicates`: Add `T: Clone`

4. **Process next Method's Own Generics**
   - ParamEnv: Empty (method has no own generics)
   - Late Bound: Lifetime of `&mut self`

5. **Final GenericParams**:
```rust
GenericParams {
    regions: ['_next_lifetime],  // Late Bound
    types: [T],                   // From impl block
    const_generics: [],
    trait_clauses: [T: Clone],    // From impl block
    regions_outlive: [],
    types_outlive: [],
    trait_type_constraints: [],
}
```

#### Key Design Decisions

**1. Why Separate Early/Late Processing**
- Early Bound: Known at compile time, needs monomorphization
- Late Bound: Locally quantified, preserve binder structure
- Separate processing ensures semantic correctness

**2. Why Process Parent Generics First**
- Ensure ordering: Parent parameters before child parameters
- Match Rust semantics: Child items can reference parent generics
- Simplify DeBruijn index calculation

**3. Why Special Handling for Closure upvars**
- Rust introduces implicit lifetimes for closures' by-ref upvars
- These lifetimes are not in ParamEnv
- Need to infer from upvar types

**4. Why Consistency Check Needed**
- Verify translation correctness
- Catch errors early
- Ensure GenericParams can be safely used

#### Collaboration with Other Functions

**Callers**:
- `translate_function_signature`
- `translate_type_decl`
- `translate_trait_decl`
- All translation functions that need generic environment

**Callees**:
- `push_generics_for_def`: Recursive collection
- `push_generic_params`: Add parameters
- `register_predicates`: Add predicates
- `push_params_from_binder`: Add Late Bound

**Subsequent Usage**:
- Look up generic variables when translating types
- Provide template when building `GenericArgs`
- Extract `GenericParams` when generating AST

This function is the cornerstone of Charon's generic system, ensuring all subsequent translation happens in the correct generic context.

## 6. Transform Stage Overview

**Purpose**: Structure cleanup and normalization, preparing clean LLBC for downstream tools

**Pass Classification**:
- **Normalize**: Normalize representation (e.g., `expand_associated_types`)
- **Simplify**: Simplify structure (e.g., `remove_unit_locals`)
- **Sanity**: Completeness checks (e.g., `check_generics`)

**Execution Order** (`transform/mod.rs`):
```
INITIAL_CLEANUP_PASSES      // Initial cleanup
  -> ULLBC_PASSES            // ULLBC-specific
  -> ullbc_to_llbc           // Control flow reconstruction
  -> LLBC_PASSES             // LLBC-specific
  -> SHARED_FINALIZING_PASSES // Final cleanup
  -> FINAL_CLEANUP_PASSES    // Completeness checks
```

**Key Pass Examples**:
- `monomorphize`: Monomorphic instantiation
- `reorder_decls`: Dependency graph ordering
- `reconstruct_asserts`: Reconstruct assertions
- `ops_to_function_calls`: Convert operators to function calls

## 7. Build and Run

### Basic Build
```bash
make build          # Release mode build (Rust + OCaml)
make build-dev      # Debug mode build
make test           # Run tests
```

### Usage Examples
```bash
# Generate LLBC for an entire Cargo project, analogous to cargo build
../bin/charon cargo

# Generate human-readable LLBC
../bin/charon rustc --print-llbc -- file.rs

# Generate JSON file
../bin/charon rustc --dest-file output.llbc -- file.rs

# Generate only ULLBC
../bin/charon rustc --ullbc --dest-file output.ullbc -- file.rs
```

### Log Debugging
```bash
# Enable all trace logs
RUST_LOG=trace ./bin/charon ...

# Filter specific module
RUST_LOG=charon::translate=debug ./bin/charon ...

# Precise control
RUST_LOG=charon::translate::translate_generics=trace ./bin/charon ...
```

## 8. Debugging and Printing

### Using the trace! Macro
```rust
// Basic tracing
trace!("Processing item: {item_id:?}");

// Context-aware printing
trace!("{}", item_ctx.with_ctx(&ctx.into_fmt()));
```

Note that because Charon stores IDs rather than concrete content, context information is needed for correct display when printing. The core context here refers to `TranslatedCrate`, which stores all ID-to-definition mappings. However, both `TranslateCtx` and `ItemTransCtx` implement corresponding trait methods and can call `into_fmt()` to be used as print context.

## 9. charon-ml Overview

**Purpose**: Generate AST type definitions and deserialization functions for OCaml downstream tools

**Command**:
```bash
make generate-ml    # Regenerate charon-ml/src/generated/
```

**Mechanism Comparison**:
- **Auto-generated**: `Generated_*.ml` - AST types + JSON parsers
- **Hand-written**: `Print*.ml`, `NameMatcher.ml` - Utility functions

**Steps to Modify AST**:
1. Modify `charon/src/ast/*.rs`
2. Run `make generate-ml`
3. **Do not directly modify** files in `charon-ml/src/generated/`
4. Manually adjust infrastructure like printing based on `make test` compilation needs
5. If AST changes occurred, also adjust the version number in `charon/Cargo.toml` to notify downstream tools of AST version changes, and run `make test` to ensure version number changes sync to `charon-ml`

## 10. Development Practices and Common Pitfalls

### Must-Run Checks
```bash
make test           # Complete test suite
cargo test          # Rust unit tests only
```

### Minimal Steps to Add a Pass
1. Create `my_pass.rs` under `transform/`
2. Implement `UllbcPass` or `LlbcPass` trait:
   ```rust
   pub struct MyPass;
   impl UllbcPass for MyPass {
       fn transform_body(&self, ctx: &mut TransformCtx, body: &mut ExprBody) {
           // Implementation logic
       }
       fn name(&self) -> &str { "MyPass" }
   }
   ```
3. Register in the appropriate array in `transform/mod.rs`
4. Add test cases

### Common Pitfalls and Solutions

**Binding Level Errors**:
- `DeBruijnIndex` calculation errors lead to variable lookup failures
- Tips:
    + Avoid using `skip_binder`; instead use `erased`, `move_under_binder()`, `move_from_under_binder()` and other intelligent handling functions
    + Note that although `RegionBinder` only binds lifetimes, it still changes the DeBruijnIndex of other information like types and Clauses, so DeBruijnIndex must be calculated very carefully

### Key Code Path Tracking

**Translation Entry Path**:
1. `charon/main.rs:main` → Set up environment
2. `charon-driver/main.rs:run_charon` → Invoke Rustc
3. `driver.rs:after_expansion` → MIR callback
4. `translate_crate.rs:translate` → Main translation loop
5. `translate_items.rs:translate_item` → Dispatch specific items

**Error Handling**: All errors are collected into `ErrorCtx` via the `register_error!` macro


## 11. Future Work: Complete Monomorphization Support

### Overview

Charon currently has framework-level support for monomorphization (via the `--monomorphize` flag), but two key limitations prevent full functionality:

1. **Incorrect Trait Definition Monomorphization**: The current mechanism generates monomorphized trait definitions that don't conform to Rust semantics
2. **Trait Objects Cannot Be Monomorphized**: `dyn Trait` types don't support monomorphization because associated types cannot be specified

Both problems stem from the current **wholesale monomorphization** strategy using `ItemRef`, requiring a redesign of the monomorphization mechanism to correctly handle trait-related scenarios.

### Problem 1: Incorrect Monomorphization of Trait Definitions

#### Current Problem Manifestation

**Current Implementation** (`translate/translate_crate.rs` line 406):
```rust
let item = if self.monomorphize() && item.has_param {
    item.erase(&self.hax_state_with_id())  // Wholesale monomorphization
} else {
    item.clone()
};
```

This approach directly monomorphizes `ItemRef`, **including trait definitions themselves**, leading to:

**Error Scenario Example**:
```rust
// Rust source
trait MyTrait<T> {
    fn process(&self, x: T) -> T;
}

impl MyTrait<i32> for i32 { }
impl MyTrait<i32> for bool { }
```

**Current Charon Output (Incorrect)**:
Not only trait impls are output, but also two monomorphized trait **definitions**:
> Note: In (U)LLBC, `T : Trait<...>` is represented as `Trait::<T, ...>` where `...` are other generic parameters of `Trait`.
```rust
// Full name: test::MyTrait::<i32, i32>
trait MyTrait::<i32, i32>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<i32>
    parent_clause1 : [@TraitClause1]: Sized::<i32>
    fn process<'_0> = test::MyTrait::process::<i32, i32><'_0_0>
    vtable: test::MyTrait::{vtable}::<i32, i32>
}

// Full name: test::MyTrait::<bool, i32>
trait MyTrait::<bool, i32>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<bool>
    parent_clause1 : [@TraitClause1]: Sized::<i32>
    fn process<'_0> = test::MyTrait::process::<bool, i32><'_0_0>
    vtable: test::MyTrait::{vtable}::<bool, i32>
}
```

**Problem Analysis**:
- In Rust semantics, there's only one trait **definition**, the Self implementation parameter should be preserved
- Trait **implementations** (impl) are what get monomorphized for specific types

**Expected Charon Output**:
```rust
// Full name: test::MyTrait::<i32>
trait MyTrait::<i32> <Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<i32>
    fn process<'_0> = test::MyTrait::process<'_0_0, Self, i32>[Self]
    vtable: test::MyTrait::{vtable}::<i32>
}
```

**Key Principles**:
- `Self` parameter: **Always preserved**, because a trait can be implemented by multiple types
- Other generic parameters: **Should be monomorphized**, generating one trait **definition** per parameter value set

#### Specific Problem Root Cause and Solution

The current monomorphized translation's `RustcItem` directly passes the **entire** `ItemRef` to Hax, and Hax directly replaces generic parameters with concrete parameters from `ItemRef` when translating **all** items. However, this **should not** include the `Self` parameter. In other words, the generated `hax::FullDef` should not contain the concrete type of `Self`. But this may cause different `RustcItem::Mono(ItemRef)` to point to the same `hax::FullDef`, resulting in different `TraitId` for the same definition. This also requires Charon cooperation to avoid overlap. An imaginable solution is to replace the first parameter with a fixed Placeholder when translating `TraitDecl` referenced by `ItemRef`, so it won't duplicate during `enqueue`, and Hax needs to translate `Self` instead of directly replacing it.


### Problem 2: Trait Objects Cannot Be Monomorphized

#### Current Problem Manifestation

**Trait object syntax**:
```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// Trait objects must explicitly specify all associated types
let iter: Box<dyn Iterator<Item = i32>> = ...;
```

**Key Requirement**: `dyn Trait` must **explicitly specify all associated types**

**Current hax::ItemRef Limitation**:
In Hax, the `ItemRef` structure cannot express associated type bindings, defined as follows:
```rust
/// Contents of `ItemRef`.
#[derive_group(Serializers)]
#[derive(Clone, Debug, JsonSchema, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct ItemRefContents {
    /// The item being refered to.
    pub def_id: DefId,
    /// The generics passed to the item. If `in_trait` is `Some`, these are only the generics of
    /// the method/type/const itself; generics for the traits are available in
    /// `in_trait.unwrap().trait`.
    pub generic_args: Vec<GenericArg>,
    /// Witnesses of the trait clauses required by the item, e.g. `T: Sized` for `Option<T>` or `B:
    /// ToOwned` for `Cow<'a, B>`. Same as above, for associated items this only includes clauses
    /// for the item itself.
    pub impl_exprs: Vec<ImplExpr>,
    /// If we're referring to a trait associated item, this gives the trait clause/impl we're
    /// referring to.
    pub in_trait: Option<ImplExpr>,
    /// Whether this contains any reference to a type/lifetime/const parameter.
    pub has_param: bool,
    /// Whether this contains any reference to a type/const parameter.
    pub has_non_lt_param: bool,
}
```

Thus, we cannot express syntax like `dyn Trait<AssocTy=T>`. This requires extending the `ItemRef` structure on the Hax side to support associated type bindings.

## Appendix

| English Term | Chinese Translation | Context Example |
|--------------|---------------------|-----------------|
| binder | 绑定器 - Syntax structure that introduces variables | `for<'a>`, `Binder<T>` |
| early bound | 早期绑定 - Determined at compile time | Type parameter `<T>` |
| late bound | 晚期绑定 - Local scope | Lifetime `for<'a>` |
| monomorphization | 单态化 - Generic instantiation | `Vec<u32>` |
| substitution | 替换 - Parameter to argument mapping | `T` → `u32` |
| instantiation | 实例化 - Creating concrete instances | Generic → Concrete type |
| visitor | 访问器 - AST traversal pattern | `Drive`, `DriveMut` |
| pass | 变换步骤 - Transform stage unit | `UllbcPass` |
| DeBruijn index | 德布勒恩索引 - Nested binding count | `Bound(1, var)` |
| enqueue | 入队 - Add to translation queue | `register_and_enqueue` |
| register | 注册 - Allocate ID | `register_no_enqueue` |
